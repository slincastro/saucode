query_id,query_text,retriever,rank,chunk_id,text,score,is_relevant
q001,long method with many if statements in Python,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p928_c1,"EAFP Easier to ask for forgiveness than permission. This common Python coding style assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. This clean and fast style is characterized by the presence of many try and except statements. The technique contrasts with the LBYL style common to many other languages such as C. The glossary then defines LBYL: LBYL Look before you leap. This coding style explicitly tests for pre- conditions before making calls or lookups. This style contrasts with the EAFP approach and is characterized by the presence of many if statements. In a multi-threaded environment, the LBYL approach can risk introducing a race condition between “the looking” and “the leaping”. For example, the code, if key in mapping: return mapping[key] can fail if another thread removes key from mapping after the test, but before the lookup. This issue can be solved with locks or by using the EAFP approach. Given the EAFP style, it makes even more sense to know and use well else blocks in try/except statements. Now let’s address the main topic of this chapter: the powerful with statement. Context Managers and with Blocks Context manager objects exist to control a with statement, just like iterators exist to control a for statement. The with statement was designed to simplify the try/finally pattern, which guarantees that some operation is performed after a block of code,",0.09190271,
q001,long method with many if statements in Python,sparse,2,cc_knowledge_book.pdf:p141_c2,"problems upon our callers. All it takes is one missing null check to send an application spinning out of control. Did you notice the fact that there wasn’t a null check in the second line of that nested if statement? What would have happened at runtime if persistentStore were null? We would have had a NullPointerException at runtime, and either someone is catching NullPointerException at the top level or they are not. Either way it’ s bad. What exactly should you do in response to a NullPointerExceptionthrown from the depths of your appli- cation? It’ s easy to say that the problem with the code above is that it is missing a null check, but in actuality, the problem is that it has too many. If you are tempted to return null from a method, consider throwing an exception or returning a S PECIAL CASE object instead. If you are calling a null-returning method from a third-party API, consider wrapping that method with a method that either throws an exception or returns a special case object.",0.073481366,
q001,long method with many if statements in Python,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p950_c1,"Chapter Summary This chapter started easily enough with discussion of else blocks in for, while, and try statements. Once you get used to the peculiar meaning of the else clause in these statements, I believe else can clarify your intentions. We then covered context managers and the meaning of the with statement, quickly moving beyond its common use to automatically close opened files. We implemented a custom context manager: the LookingGlass class with the __enter__/__exit__ methods, and saw how to handle exceptions in the __exit__ method. A key point that Raymond Hettinger made in his PyCon US 2013 keynote is that with is not just for resource management, but it’s a tool for factoring out common setup and teardown code, or any pair of operations that need to be done before and after another procedure (slide 21, What Makes Python Awesome?). Finally, we reviewed functions in the contextlib standard library module. One of them, the @contextmanager decorator, makes it possible to implement a context manager using a simple generator with one yield—a leaner solution than coding a class with at least two methods. We reimplemented the LookingGlass as a looking_glass generator function, and discussed how to do exception handling when using @contextmanager. The @contextmanager decorator is an elegant and practical tool that brings together three distinctive Python features: a function decorator, a generator, and the with statement. Further Reading Chapter 8, “Compound Statements,” in The Python Language Reference says pretty much everything there is to say about else clauses in if, for, while, and try statements. Regarding Pythonic usage of try/except, with or without else, Raymond Hettinger has a brilliant answer to the",0.063036546,
q001,long method with many if statements in Python,sparse,4,cc_knowledge_book.pdf:p293_c1,"262 Chapter 15: JUnit Internals We replaced the +1s in computeCommonSuffix with a -1 in charFromEnd, where it makes perfect sense, and two <= operators in suffixOverlapsPrefix, where they also make perfect sense. This allowed us to change the name of suffixIndex to suffixLength, greatly enhanc- ing the readability of the code. There is a problem however. As I was eliminating the +1s, I noticed the following line in compactString: if (suffixLength > 0) Take a look at it in Listing 15-4. By rights, because suffixLength is now one less than it used to be, I should change the > operator to a >= operator. But that makes no sense. It makes sense now! This means that it didn’t use to make sense and was probably a bug. Well, not quite a bug. Upon further analysis we see that the if statement now prevents a zero length sufﬁx from being appended. Before we made the change, the if statement was nonfunctional because suffixIndex could never be less than one! This calls into question both if statements in compactString! It looks as though they could both be eliminated. So let’ s comment them out and run the tests. They passed! So let’ s restructure compactString to eliminate the extraneous if statements and make the function much simpler [G9]. private String compactString(String source) { return computeCommonPrefix() + DELTA_START + source.substring(prefixLength, source.length() - suffixLength) + DELTA_END + computeCommonSuffix(); } This is much better! Now we see that the compactString function is simply composing the fragments together. We can probably make this even clearer. Indeed, there are lots of little if (suffixLength > 0) result = result + computeCommonSuffix(); return result; } ... private String computeCommonSuffix() { int end = Math.min(expected.length() - suffixLength + contextLength, expected.length() );",0.062122464,
q001,long method with many if statements in Python,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p924_c1,"Chapter 18. Context Managers and else Blocks A NOTE FOR EARLY RELEASE READERS With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles. This will be the 18th chapter of the final book. Please note that the GitHub repo will be made active later on. If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at fluentpython2e@ramalho.org. Context managers may end up being almost as important as the subroutine itself. We’ve only scratched the surface with them. […] Basic has a with statement, there are with statements in lots of languages. But they don’t do the same thing, they all do something very shallow, they save you from repeated dotted [attribute] lookups, they don’t do setup and tear down. Just because it’s the same name don’t think it’s the same thing. The with statement is a very big deal. —Raymond Hettinger, Eloquent Python evangelist In this chapter, we will discuss control flow features that are not so common in other languages, and for this reason tend to be overlooked or underused in Python. They are: The with statement and context managers. The else clause in for, while, and try statements. 1",0.060010657,
q002,refactoring guidelines for high cyclomatic complexity,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1104_c1,"BE CAREFUL WHEN TESTING CONCURRENTCLIENTS When testing concurrent HTTP clients on public Web servers, you may generate many requests per second, and that’s how denial-of-service (DoS) attacks are made. Carefully throttle your clients when hitting public servers. For high-concurrency experiments, set up a local HTTP server for testing. The ThreadingHTTPServer that comes with Python is OK for testing, and it can serve files in the current directory if you run it with: python -m http.server Append the -h option to the command above for more options. The most visible feature of the flags2 examples is that they have an animated, text-mode progress bar implemented with the TQDM package. I posted a 108s video on YouTube to show the progress bar and contrast the speed of the three flags2 scripts. In the video, I start with the sequential download, but I interrupt it after 32s because it was going to take more than 5 minutes to hit on 676 URLs and get 194 flags; I then run the threaded and asyncio scripts three times each, and every time they complete the job in 6s or less (i.e., more than 60 times faster). Figure 21-1 shows two screenshots: during and after running flags2_threadpool.py. 5",0.047115535,
q002,refactoring guidelines for high cyclomatic complexity,sparse,2,cc_knowledge_book.pdf:p169_c1,"138 Chapter 10: Classes But what if SuperDashboard contained only the methods shown in Listing 10-2? Five methods isn’t too much, is it? In this case it is because despite its small number of methods, SuperDashboard has too many responsibilities. The name of a class should describe what responsibilities it fulﬁlls. In fact, naming is probably the ﬁrst way of helping determine class size. If we cannot derive a concise name for a class, then it’ s likely too large. The more ambiguous the class name, the more likely it has too many responsibilities. For example, class names including weasel words like Processor or Manager or Super often hint at unfortunate aggregation of responsibilities. We should also be able to write a brief description of the class in about 25 words, without using the words “if,” “and,” “or,” or “but.” How would we describe the SuperDashboard? “The SuperDashboard provides access to the component that last held the focus, and it also allows us to track the version and build numbers.” The ﬁrst “and” is a hint that SuperDashboard has too many responsibilities. The Single Responsibility Principle The Single Responsibility Principle (SRP)2 states that a class or module should have one, and only one, reason to change. This principle gives us both a deﬁnition of responsibility, and a guidelines for class size. Classes should have one responsibility—one reason to change. public void setAçowDragging(boolean allowDragging) public boolean allowDragging() public boolean isCustomizing() public void setTitle(String title) public IdeMenuBar getIdeMenuBar() public void showHelper(MetaObject metaObject, String propertyName) // ... many non-public methods follow ... } Listing 10-2 Small Enough? public class SuperDashboard extends JFrame implements MetaDataUser public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() } 2. Y ou can read much more about this principle in [PPP].",0.046428785,
q002,refactoring guidelines for high cyclomatic complexity,sparse,3,cc_knowledge_book.pdf:p203_c2,"coupling. Our designs improve even more. Remarkably, following a simple and obvious rule that says we need to have tests and run them continuously impacts our system’ s adherence to the primary OO goals of low coupling and high cohesion. Writing tests leads to better designs. Simple Design Rules 2–4: Refactoring Once we have tests, we are empowered to keep our code and classes clean. We do this by incrementally refactoring the code. For each few lines of code we add, we pause and reﬂect on the new design. Did we just degrade it? If so, we clean it up and run our tests to demon- strate that we haven’t broken anything. The fact that we have these tests eliminates the fear that cleaning up the code will break it! During this refactoring step, we can apply anything from the entire body of knowledge about good software design. We can increase cohesion, decrease coupling, separate con- cerns, modularize system concerns, shrink our functions and classes, choose better names, and so on. This is also where we apply the ﬁnal three rules of simple design: Eliminate duplication, ensure expressiveness, and minimize the number of classes and methods.",0.04344216,
q002,refactoring guidelines for high cyclomatic complexity,sparse,4,cc_knowledge_book.pdf:p316_c1,"285 17 Smells and Heuristics In his wonderful book Refactoring,1 Martin Fowler identiﬁed many different “Code Smells.” The list that follows includes many of Martin’ s smells and adds many more of my own. It also includes other pearls and heuristics that I use to practice my trade. 1. [Refactoring].",0.042944077,
q002,refactoring guidelines for high cyclomatic complexity,sparse,5,cc_knowledge_book.pdf:p184_c1,"153 11 Systems by Dr. Kevin Dean Wampler “Complexity kills. It sucks the life out of developers, it makes products difﬁcult to plan, build, and test. ” —Ray Ozzie, CTO, Microsoft Corporation",0.03442965,
q003,clean code practices for data preprocessing pipelines,sparse,1,cc_knowledge_book.pdf:p2_c1,Clean Code,0.4417313,
q003,clean code practices for data preprocessing pipelines,sparse,2,cc_knowledge_book.pdf:p37_c2,"deadlines. In short, they don’t take the time to go fast! True professionals know that the second part of the conundrum is wrong. Y ou will not make the deadline by making the mess. Indeed, the mess will slow you down instantly, and will force you to miss the deadline. The only way to make the deadline—the only way to go fast—is to keep the code as clean as possible at all times. The Art of Clean Code? Let’ s say you believe that messy code is a signiﬁcant impediment. Let’ s say that you accept that the only way to go fast is to keep your code clean. Then you must ask yourself: “How do I write clean code?” It’ s no good trying to write clean code if you don’t know what it means for code to be clean! The bad news is that writing clean code is a lot like painting a picture. Most of us know when a picture is painted well or badly. But being able to recognize good art from bad does not mean that we know how to paint. So too being able to recognize clean code from dirty code does not mean that we know how to write clean code! 2. When hand-washing was ﬁrst recommended to physicians by Ignaz Semmelweis in 1847, it was rejected on the basis that doctors were too busy and wouldn’t have time to wash their hands between patient visits.",0.15120602,
q003,clean code practices for data preprocessing pipelines,sparse,3,cc_knowledge_book.pdf:p39_c2,"undistracted, and unpolluted, by the surrounding details. Grady Booch, author of Object Oriented Analysis and Design with Applications Clean code is simple and direct. Clean code reads like well-written prose. Clean code never obscures the designer’ s intent but rather is full of crisp abstractions and straightforward lines of control. Grady makes some of the same points as Bjarne, but he takes a readability perspective. I especially like his view that clean code should read like well-written prose. Think back on a really good book that you’ve read. Remember how the words disappeared to be replaced by images! It was like watching a movie, wasn’t it? Better! Y ou saw the characters, you heard the sounds, you experienced the pathos and the humor. Reading clean code will never be quite like reading Lord of the Rings. Still, the liter- ary metaphor is not a bad one. Like a good novel, clean code should clearly expose the ten- sions in the problem to be solved. It should build those tensions to a climax and then give 3. http://www.pragmaticprogrammer.com/booksellers/2004-12.html",0.14433047,
q003,clean code practices for data preprocessing pipelines,sparse,4,cc_knowledge_book.pdf:p39_c1,"8 Chapter 1: Clean Code to describe the consequence of that inelegance. He uses the word “tempt.” There is a deep truth here. Bad code tempts the mess to grow! When others change bad code, they tend to make it worse. Pragmatic Dave Thomas and Andy Hunt said this a different way. They used the meta- phor of broken windows.3 A building with broken windows looks like nobody cares about it. So other people stop caring. They allow more windows to become broken. Eventually they actively break them. They despoil the facade with grafﬁti and allow garbage to col- lect. One broken window starts the process toward decay. Bjarne also mentions that error handing should be complete. This goes to the disci- pline of paying attention to details. Abbreviated error handling is just one way that pro- grammers gloss over details. Memory leaks are another, race conditions still another. Inconsistent naming yet another. The upshot is that clean code exhibits close attention to detail. Bjarne closes with the assertion that clean code does one thing well. It is no accident that there are so many principles of software design that can be boiled down to this simple admonition. Writer after writer has tried to communicate this thought. Bad code tries to do too much, it has muddled intent and ambiguity of purpose. Clean code is focused. Each function, each class, each module exposes a single-minded attitude that remains entirely undistracted, and unpolluted, by the surrounding details. Grady Booch, author of Object Oriented Analysis and Design with Applications Clean code is simple and direct. Clean code reads like well-written prose. Clean code never obscures the designer’ s intent but rather is full of crisp abstractions and straightforward lines of control.",0.13443097,
q003,clean code practices for data preprocessing pipelines,sparse,5,cc_knowledge_book.pdf:p8_c1,vii Contents Foreword................................................................................................ xix Introduction ..........................................................................................xxv On the Cover....................................................................................... xxix Chapter 1: Clean Code........................................................................1 There Will Be Code...............................................................................2 Bad Code................................................................................................3 The Total Cost of Owning a Mess........................................................4 The Grand Redesign in the Sky..........................................................5 Attitude...............................................................................................5 The Primal Conundrum......................................................................6 The Art of Clean Code?......................................................................6 What Is Clean Code?..........................................................................7 Schools of Thought..............................................................................12 We Are Authors....................................................................................13 The Boy Scout Rule.............................................................................14 Prequel and Principles........................................................................15 Conclusion............................................................................................15 Bibliography.........................................................................................15 Chapter 2: Meaningful Names.......................................................17 Introduction.........................................................................................17 Use Intention-Revealing Names.........................................................18 Avoid Disinformation..........................................................................19 Make Meaningful Distinctions...........................................................20 Use Pronounceable Names..................................................................21 Use Searchable Names........................................................................22,0.10873215,
q004,code smell: long parameter list in service functions,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p309_c1,"These are classes that have fields, getting and setting methods for fields, and nothing else. Such classes are dumb data holders and are often being manipulated in far too much detail by other classes. In Fowler’s personal Web site there’s an illuminating post titled Code Smell. The post is very relevant to our discussion because he uses data class as one example of a code smell and suggests how to deal with it. Here is the post, reproduced in full.9",0.14290151,
q004,code smell: long parameter list in service functions,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p310_c1,"CODE SMELL By Martin Fowler A code smell is a surface indication that usually corresponds to a deeper problem in the system. The term was first coined by Kent Beck while helping me with my Refactoring book. The quick definition above contains a couple of subtle points. Firstly a smell is by definition something that’s quick to spot—or sniffable as I’ve recently put it. A long method is a good example of this—just looking at the code and my nose twitches if I see more than a dozen lines of Java. The second is that smells don’t always indicate a problem. Some long methods are just fine. You have to look deeper to see if there is an underlying problem there—smells aren’t inherently bad on their own— they are often an indicator of a problem rather than the problem themselves. The best smells are something that’s easy to spot and most of time lead you to really interesting problems. Data classes (classes with all data and no behavior) are good examples of this. You look at them and ask yourself what behavior should be in this class. Then you start refactoring to move that behavior in there. Often simple questions and initial refactorings can be the vital step in turning anemic objects into something that really has class. One of the nice things about smells is that it’s easy for inexperienced people to spot them, even if they don’t know enough to evaluate if there’s a real problem or to correct them. I’ve heard of lead developers who will pick a “smell of the week” and ask people to look for the smell and bring it up with the senior members of the team.",0.1318067,
q004,code smell: long parameter list in service functions,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p310_c2,"them, even if they don’t know enough to evaluate if there’s a real problem or to correct them. I’ve heard of lead developers who will pick a “smell of the week” and ask people to look for the smell and bring it up with the senior members of the team. Doing it one smell at a time is a good way of gradually teaching people on the team to be better programmers.",0.10573017,
q004,code smell: long parameter list in service functions,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p319_c1,"dunder methods).” The influence of attrs on @dataclass is acknowledged by Eric V. Smith in PEP 557. This probably includes Smith’s most important API decision: the use of a class decorator instead of a base class and/or a metaclass to do the job. Glyph—founder of the Twisted project—wrote an excellent introduction to attrs in The One Python Library Everyone Needs. The attrs documentation includes a discussion of alternatives. Book author, instructor, and mad computer scientist Dave Beazley wrote cluegen, yet another data class generator. If you’ve seen any of Dave’s talks, you know he is a master of metaprograming Python from first principles. So, I found it inspiring to learn from the cluegen README.md file the concrete use case that motivated him to write an alternative to Python’s @dataclass, and his philosophy of presenting an approach to solve the problem, in contrast to providing a tool: the tool may be quicker to use at first, but the approach is more flexible and can take you as far as you want to go. Regarding Data Class as a code smell, the best source I found was Martin Fowler’s book Refactoring, Second Edition. This newest version is missing the quote from the epigraph of this chapter, “Data classes are like children…”, but otherwise it’s the best edition of Fowler’s most famous book, particularly for Pythonistas because the examples are in modern JavaScript, which is closer to Python than Java—the language of the first edition. The Web site Refactoring Guru also has a description of the Data Class code smell.",0.0777663,
q004,code smell: long parameter list in service functions,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p723_c2,"but it is an interface, and Widget “defines” it as the union of the interfaces of its superclasses. The Tk class, which encapsulates the GUI application logic, inherits from Wm and Misc, neither of which are abstract or mixin (Wm is not proper mixin because TopLevel subclasses only from it). The name of the Misc class is—by itself—a very strong code smell. Misc has more than 100 methods, and all widgets inherit from it. Why is it necessary that every",0.07002266,
q005,best practices to reduce nested loops and branches,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p597_c1,"Figure 12-1. Reducing functions—reduce, sum, any, all—produce a single aggregate result from a sequence or from any finite iterable object. So far we’ve seen that functools.reduce() can be replaced by sum(), but now let’s properly explain how it works. The key idea is to reduce a series of values to a single value. The first argument to reduce() is a two-argument function, and the second argument is an iterable. Let’s say we have a two-argument function fn and a list lst. When you call reduce(fn, lst), fn will be applied to the first pair of elements—fn(lst[0], lst[1])—producing a first result, r1. Then fn is applied to r1 and the next element—fn(r1, lst[2])— producing a second result, r2. Now fn(r2, lst[3]) is called to produce r3 … and so on until the last element, when a single result, rN, is returned. Here is how you could use reduce to compute 5! (the factorial of 5): >>> 2 * 3 * 4 * 5 # the result we want: 5! == 120 120 >>> import functools >>> functools.reduce(lambda a,b: a*b, range(1, 6)) 120",0.088227496,
q005,best practices to reduce nested loops and branches,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p367_c1,"Example 7-6. Sum of integers up to 99 performed with reduce and sum >>> from functools import reduce >>> from operator import add >>> reduce(add, range(100)) 4950 >>> sum(range(100)) 4950 >>> Starting with Python 3.0, reduce is no longer a built-in. Import add to avoid creating a function just to add two numbers. Sum integers up to 99. Same task with sum—no need to import and call reduce and add. NOTE The common idea of sum and reduce is to apply some operation to successive items in a sequence, accumulating previous results, thus reducing a sequence of values to a single value. Other reducing built-ins are all and any: all(iterable) Returns True if there are no falsy elements in the iterable; all([]) returns True. any(iterable) Returns True if any element of the iterable is truthy; any([]) returns False. I give a fuller explanation of reduce in “Vector Take #4: Hashing and a Faster ==” where an ongoing example provides a meaningful context for",0.07334377,
q005,best practices to reduce nested loops and branches,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p141_c1,"Chapter 3. Dictionaries and Sets A NOTE FOR EARLY RELEASE READERS With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles. This will be the 3rd chapter of the final book. Please note that the GitHub repo will be made active later on. If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at fluentpython2e@ramalho.org. Python is basically dicts wrapped in loads of syntactic sugar. —Lalo Martins, early digital nomad and Pythonista. We use dictionaties in all our Python programs. If not directly in our code, then indirectly because the dict type is a fundamental part of Python’s implementation. Class and instance attributes, module namespaces, and function keyword arguments are some of the core Python constructs represented by dictionaries in memory. The __builtins__.__dict__ stores all built-in types, objects, and functions. Because of their crucial role, Python dicts are highly optimized—and continue to get improvements. Hash tables are the engines behind Python’s high- performance dicts. Other built-in types based on hash tables are set and frozenset. These offer richer APIs and operators than the sets you may have encountered in other popular languages. In particular, Python sets implement all the fundamental operations from set theory, like union, intersection, subset tests etc. With them, we can express algorithms in a more declarative way, avoiding lots of nested loops and conditionals.",0.063769095,
q005,best practices to reduce nested loops and branches,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p601_c1,"Figure 12-2. Map-reduce: apply function to each item to generate a new series (map), then compute aggregate (reduce) The mapping step produces one hash for each component, and the reduce step aggregates all hashes with the xor operator. Using map instead of a genexp makes the mapping step even more visible: def __hash__(self): hashes = map(hash, self._components) return functools.reduce(operator.xor, hashes)",0.061464097,
q005,best practices to reduce nested loops and branches,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p259_c2,"syntax details, codecs, regular expressions, filenames, and best practices for Unicode- aware I/O (i.e., the Unicode sandwich), with plenty of additional reference links from each section. Chapter 4, “Strings”, of Mark Pilgrim’s awesome book Dive into Python 3 also provides a very good intro to Unicode support in Python 3. In the same book, Chapter 15 describes how the Chardet library was ported from Python 2 to Python 3, a valuable case study given that the switch from the old str to the new bytes is the cause of most",0.060115717,
q006,how to refactor duplicated code across multiple modules,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p704_c1,">>> class DoppelDict(dict): ... def __setitem__(self, key, value): ... super().__setitem__(key, [value] * 2) ... >>> dd = DoppelDict(one=1) >>> dd {'one': 1} >>> dd['two'] = 2 >>> dd {'one': 1, 'two': [2, 2]} >>> dd.update(three=3) >>> dd {'three': 3, 'one': 1, 'two': [2, 2]} DoppelDict.__setitem__ duplicates values when storing (for no good reason, just to have a visible effect). It works by delegating to the superclass. The __init__ method inherited from dict clearly ignored that __setitem__ was overridden: the value of 'one' is not duplicated. The [] operator calls our __setitem__ and works as expected: 'two' maps to the duplicated value [2, 2]. The update method from dict does not use our version of __setitem__ either: the value of 'three' was not duplicated. This built-in behavior is a violation of a basic rule of object-oriented programming: the search for methods should always start from the class of the target instance (self), even when the call happens inside a method implemented in a superclass. In this sad state of affairs, the __missing__ method—which we saw in “The __missing__ Method”—works as documented only because it’s handled as a special case. The problem is not limited to calls within an instance—whether self.get() calls self.__getitem__())—but also happens with overridden methods of other classes that should be called by the built-in",0.051391028,
q006,how to refactor duplicated code across multiple modules,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1047_c1,"def check(n: int) -> Result: t0 = perf_counter() prime = is_prime(n) return Result(prime, perf_counter() - t0) def main() -> None: print(f'Checking {len(NUMBERS)} numbers sequentially:') t0 = perf_counter() for n in NUMBERS: prime, elapsed = check(n) label = 'P' if prime else ' ' print(f'{n:16} {label} {elapsed:9.6f}s') elapsed = perf_counter() - t0 print(f'Total time: {elapsed:.2f}s') if __name__ == '__main__': main() The check function (below) returns a Result tuple with the boolean value of the is_prime call and the elapsed time. check(n) calls is_prime(n) and computes the elapsed time to return a Result. For each number in the sample, we call check and display the result. Compute and display the total elapsed time. Process-based Solution The next example, procs.py, shows the use of multiple processes to distribute the primality checks across multiple CPU cores. These are the times I get with procs.py: $ python3 procs.py Checking 20 numbers with 12 processes: 2 P 0.000002s 3333333333333333 0.000021s 4444444444444444 0.000002s 5555555555555555 0.000018s",0.04961384,
q006,how to refactor duplicated code across multiple modules,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p506_c2,"is to show how—in some cases—functions can do the same work as classes, with code that is shorter and easier to read. We will refactor an implementation of Strategy using functions as objects, removing a lot of boilerplate code. We’ll also discuss a similar approach to simplifying the Command pattern. What’s new in this chapter 2",0.047615886,
q006,how to refactor duplicated code across multiple modules,sparse,4,cc_knowledge_book.pdf:p205_c1,"174 Chapter 12: Emergence replaceImage(ImageUtilities.getScaledImage( image, scalingFactor, scalingFactor)); } public synchronized void rotate(int degrees) { replaceImage(ImageUtilities.getRotatedImage(image, degrees)); } private void replaceImage(RenderedOp newImage) { image.dispose(); System.gc(); image = newImage; } As we extract commonality at this very tiny level, we start to recognize violations of SRP . So we might move a newly extracted method to another class. That elevates its visibility. Someone else on the team may recognize the opportunity to further abstract the new method and reuse it in a different context. This “reuse in the small” can cause system com- plexity to shrink dramatically. Understanding how to achieve reuse in the small is essential to achieving reuse in the large. The T EMPLATE METHOD2 pattern is a common technique for removing higher-level duplication. For example: public class VacationPolicy { public void accrueUSDivisionVacation() { // code to calculate vacation based on hours worked to date // ... // code to ensure vacation meets US minimums // ... // code to apply vaction to payroll record // ... } public void accrueEUDivisionVacation() { // code to calculate vacation based on hours worked to date // ... // code to ensure vacation meets EU minimums // ... // code to apply vaction to payroll record // ... } } The code across accrueUSDivisionVacation and accrueEuropeanDivisionVacation is largely the same, with the exception of calculating legal minimums. That bit of the algorithm changes based on the employee type. We can eliminate the obvious duplication by applying the T EMPLATE METHOD pattern. abstract public class VacationPolicy { public void accrueVacation() { calculateBaseVacationHours(); 2. [GOF].",0.047573812,
q006,how to refactor duplicated code across multiple modules,sparse,5,cc_knowledge_book.pdf:p80_c1,"49Conclusion While we are sympathetic to the goals and disciplines of structured programming, those rules serve little beneﬁt when functions are very small. It is only in larger functions that such rules provide signiﬁcant beneﬁt. So if you keep your functions small, then the occasional multiple return, break, or continue statement does no harm and can sometimes even be more expressive than the sin- gle-entry, single-exit rule. On the other hand, goto only makes sense in large functions, so it should be avoided. How Do Y ou Write Functions Like This? Writing software is like any other kind of writing. When you write a paper or an article, you get your thoughts down ﬁrst, then you massage it until it reads well. The ﬁrst draft might be clumsy and disorganized, so you wordsmith it and restructure it and reﬁne it until it reads the way you want it to read. When I write functions, they come out long and complicated. They have lots of indenting and nested loops. They have long argument lists. The names are arbitrary, and there is duplicated code. But I also have a suite of unit tests that cover every one of those clumsy lines of code. So then I massage and reﬁne that code, splitting out functions, changing names, elim- inating duplication. I shrink the methods and reorder them. Sometimes I break out whole classes, all the while keeping the tests passing. In the end, I wind up with functions that follow the rules I’ve laid down in this chapter. I don’t write them that way to start. I don’t think anyone could. Conclusion Every system is built from a domain-speciﬁc language designed by the programmers to describe that system. Functions are the verbs of that language, and classes are the nouns.",0.04696341,
q007,improving readability in deeply nested try except blocks,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p927_c1,"else: raise ValueError('No banana flavor found!') In the case of try/except blocks, else may seem redundant at first. After all, the after_call() in the following snippet will run only if the dangerous_call() does not raise an exception, correct? try: dangerous_call() after_call() except OSError: log('OSError...') However, doing so puts the after_call() inside the try block for no good reason. For clarity and correctness, the body of a try block should only have the statements that may generate the expected exceptions. This is much better: try: dangerous_call() except OSError: log('OSError...') else: after_call() Now it’s clear that the try block is guarding against possible errors in dangerous_call() and not in after_call(). It’s also more obvious that after_call() will only execute if no exceptions are raised in the try block. In Python, try/except is commonly used for control flow, and not just for error handling. There’s even an acronym/slogan for that documented in the official Python glossary:",0.13492599,
q007,improving readability in deeply nested try except blocks,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p989_c1,"forwarded as a next(…) call on the subgenerator; only if the caller sends a non-None value, the .send(…) method of the subgenerator is used. For your convenience, I present here the complete pseudocode of the yield from expansion from PEP 380, with numbered annotations. Example 19-19 was copied verbatim; I only added the callout numbers. Most of the logic of the yield from pseudocode is implemented in six try/except blocks nested up to four levels deep, so it’s a bit hard to read. The only other control flow keywords used are one while, one if, and one yield. Find the while, the yield, the next(…), and the .send(…) calls: they will help you get an idea of how the whole structure works. Remember that all the code shown in Example 19-19 is an expansion of this single statement, in the body of a delegating generator: RESULT = yield from EXPR Example 19-19. Pseudocode equivalent to the statement RESULT = yield from EXPR in the delegating generator _i = iter(EXPR) try: _y = next(_i) except StopIteration as _e: _r = _e.value else: while 1: try: _s = yield _y except GeneratorExit as _e: try: _m = _i.close except AttributeError: pass else: _m() raise _e except BaseException as _e: _x = sys.exc_info() try: _m = _i.throw",0.10736038,
q007,improving readability in deeply nested try except blocks,sparse,3,cc_knowledge_book.pdf:p77_c1,"46 Chapter 3: Functions could try to resolve this by renaming the set function to setAndCheckIfExists, but that doesn’t much help the readability of the if statement. The real solution is to separate the command from the query so that the ambiguity cannot occur. if (attributeExists(""username"")) { setAttribute(""username"", ""unclebob""); ... } Prefer Exceptions to Returning Error Codes Returning error codes from command functions is a subtle violation of command query separation. It promotes commands being used as expressions in the predicates of if state- ments. if (deletePage(page) == E_OK) This does not suffer from verb/adjective confusion but does lead to deeply nested struc- tures. When you return an error code, you create the problem that the caller must deal with the error immediately. if (deletePage(page) == E_OK) { if (registry.deleteReference(page.name) == E_OK) { if (configKeys.deleteKey(page.name.makeKey()) == E_OK){ logger.log(""page deleted""); } else { logger.log(""configKey not deleted""); } } else { logger.log(""deleteReference from registry failed""); } } else { logger.log(""delete failed""); return E_ERROR; } On the other hand, if you use exceptions instead of returned error codes, then the error processing code can be separated from the happy path code and can be simpliﬁed: try { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } catch (Exception e) { logger.log(e.getMessage()); } Extract Try/Catch Blocks Try/catch blocks are ugly in their own right. They confuse the structure of the code and mix error processing with normal processing. So it is better to extract the bodies of the try and catch blocks out into functions of their own.",0.08818917,
q007,improving readability in deeply nested try except blocks,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p928_c1,"EAFP Easier to ask for forgiveness than permission. This common Python coding style assumes the existence of valid keys or attributes and catches exceptions if the assumption proves false. This clean and fast style is characterized by the presence of many try and except statements. The technique contrasts with the LBYL style common to many other languages such as C. The glossary then defines LBYL: LBYL Look before you leap. This coding style explicitly tests for pre- conditions before making calls or lookups. This style contrasts with the EAFP approach and is characterized by the presence of many if statements. In a multi-threaded environment, the LBYL approach can risk introducing a race condition between “the looking” and “the leaping”. For example, the code, if key in mapping: return mapping[key] can fail if another thread removes key from mapping after the test, but before the lookup. This issue can be solved with locks or by using the EAFP approach. Given the EAFP style, it makes even more sense to know and use well else blocks in try/except statements. Now let’s address the main topic of this chapter: the powerful with statement. Context Managers and with Blocks Context manager objects exist to control a with statement, just like iterators exist to control a for statement. The with statement was designed to simplify the try/finally pattern, which guarantees that some operation is performed after a block of code,",0.05738035,
q007,improving readability in deeply nested try except blocks,sparse,5,cc_knowledge_book.pdf:p96_c1,"65Bad Comments These comments are so noisy that we learn to ignore them. As we read through code, our eyes simply skip over them. Eventually the comments begin to lie as the code around them changes. The ﬁrst comment in Listing 4-4 seems appropriate. 2 It explains why the catch block is being ignored. But the second comment is pure noise. Apparently the programmer was just so frustrated with writing try/catch blocks in this function that he needed to vent. Rather than venting in a worthless and noisy comment, the programmer should have recognized that his frustration could be resolved by improving the structure of his code. He should have redirected his energy to extracting that last try/catch block into a separate function, as shown in Listing 4-5. 2. The current trend for IDEs to check spelling in comments will be a balm for those of us who read a lot of code. Listing 4-4 startSending private void startSending() { try { doSending(); } catch(SocketException e) { // normal. someone stopped the request. } catch(Exception e) { try { response.add(ErrorResponder.makeExceptionString(e)); response.closeAll(); } catch(Exception e1) { //Give me a break! } } } Listing 4-5 startSending (refactored) private void startSending() { try { doSending(); }",0.053154744,
q008,patterns to simplify large python classes with too many responsibilities,sparse,1,cc_knowledge_book.pdf:p169_c1,"138 Chapter 10: Classes But what if SuperDashboard contained only the methods shown in Listing 10-2? Five methods isn’t too much, is it? In this case it is because despite its small number of methods, SuperDashboard has too many responsibilities. The name of a class should describe what responsibilities it fulﬁlls. In fact, naming is probably the ﬁrst way of helping determine class size. If we cannot derive a concise name for a class, then it’ s likely too large. The more ambiguous the class name, the more likely it has too many responsibilities. For example, class names including weasel words like Processor or Manager or Super often hint at unfortunate aggregation of responsibilities. We should also be able to write a brief description of the class in about 25 words, without using the words “if,” “and,” “or,” or “but.” How would we describe the SuperDashboard? “The SuperDashboard provides access to the component that last held the focus, and it also allows us to track the version and build numbers.” The ﬁrst “and” is a hint that SuperDashboard has too many responsibilities. The Single Responsibility Principle The Single Responsibility Principle (SRP)2 states that a class or module should have one, and only one, reason to change. This principle gives us both a deﬁnition of responsibility, and a guidelines for class size. Classes should have one responsibility—one reason to change. public void setAçowDragging(boolean allowDragging) public boolean allowDragging() public boolean isCustomizing() public void setTitle(String title) public IdeMenuBar getIdeMenuBar() public void showHelper(MetaObject metaObject, String propertyName) // ... many non-public methods follow ... } Listing 10-2 Small Enough? public class SuperDashboard extends JFrame implements MetaDataUser public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() } 2. Y ou can read much more about this principle in [PPP].",0.14493081,
q008,patterns to simplify large python classes with too many responsibilities,sparse,2,cc_knowledge_book.pdf:p169_c2,String propertyName) // ... many non-public methods follow ... } Listing 10-2 Small Enough? public class SuperDashboard extends JFrame implements MetaDataUser public Component getLastFocusedComponent() public void setLastFocused(Component lastFocused) public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() } 2. Y ou can read much more about this principle in [PPP]. Listing 10-1 (continued) Too Many Responsibilities,0.10018232,
q008,patterns to simplify large python classes with too many responsibilities,sparse,3,cc_knowledge_book.pdf:p167_c2,"physical lines. With classes we use a different measure. We count responsibilities. 1 Listing 10-1 outlines a class, SuperDashboard, that exposes about 70 public methods. Most developers would agree that it’ s a bit too super in size. Some developers might refer to SuperDashboard as a “God class.” 1. [RDD]. Listing 10-1 Too Many Responsibilities public class SuperDashboard extends JFrame implements MetaDataUser public String getCustomizerLanguagePath() public void setSystemConfigPath(String systemConfigPath) public String getSystemConfigDocument() public void setSystemConfigDocument(String systemConfigDocument) public boolean getGuruState() public boolean getNoviceState() public boolean getOpenSourceState() public void showObject(MetaObject object) public void showProgress(String s)",0.089942485,
q008,patterns to simplify large python classes with too many responsibilities,sparse,4,cc_knowledge_book.pdf:p170_c2,"wholly appropriate. Maintaining a separation of concerns is just as important in our programming activities as it is in our programs. The problem is that too many of us think that we are done once the program works. We fail to switch to the other concern of organization and cleanliness. We move on to the next problem rather than going back and breaking the overstuffed classes into decoupled units with single responsibilities. At the same time, many developers fear that a large number of small, single-purpose classes makes it more difﬁcult to understand the bigger picture. They are concerned that they must navigate from class to class in order to ﬁgure out how a larger piece of work gets accomplished. However, a system with many small classes has no more moving parts than a system with a few large classes. There is just as much to learn in the system with a few large classes. So the question is: Do you want your tools organized into toolboxes with many small drawers each containing well-deﬁned and well-labeled components? Or do you want a few drawers that you just toss everything into? Every sizable system will contain a large amount of logic and complexity. The pri- mary goal in managing such complexity is to organize it so that a developer knows where Listing 10-3 A single-responsibility class public class Version { public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() }",0.08665103,
q008,patterns to simplify large python classes with too many responsibilities,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p530_c1,"SOAPBOX Python has first-class functions and first-class types, features that Norvig claims affect 10 of the 23 patterns (slide 10 of Design Patterns in Dynamic Languages). In the Chapter 9, we saw that Python also has generic functions (“Single Dispatch Generic Functions”), a limited form of the CLOS multimethods that Gamma et al. suggest as a simpler way to implement the classic Visitor pattern. Norvig, on the other hand, says that multimethods simplify the Builder pattern (slide 10). Matching design patterns to language features is not an exact science. In classrooms around the world, design patterns are frequently taught using Java examples. I’ve heard more than one student claim that they were led to believe that the original design patterns are useful in any implementation language. It turns out that the “classic” 23 patterns from the Gamma et al. book apply to “classic” Java very well in spite of being originally presented mostly in the context of C++—a few have Smalltalk examples in the book. But that does not mean every one of those patterns applies equally well in any language. The authors are explicit right at the beginning of their book that “some of our patterns are supported directly by the less common object-oriented languages” (recall full quote on first page of this chapter). The Python bibliography about design patterns is very thin, compared to that of Java, C++, or Ruby. In “Further Reading” I mentioned Learning Python Design Patterns by Gennadiy Zlobin, which was published as recently as November 2013. In contrast, Russ Olsen’s Design Patterns in Ruby was published in 2007 and has 384 pages— 284 more than Zlobin’s work. Now that Python is becoming increasingly popular in academia, let’s hope more will be written about design patterns in the context of this language.",0.080064654,
q009,refactoring strategy for functions doing IO and business logic together,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p507_c1,"I moved this chapter to the end of Part III so I could apply a registration decorator in “Decorator-Enhanced Strategy Pattern” and also use type hints in the examples. Most type hints used in this chapter are not complicated, and they do help with readability. Case Study: Refactoring Strategy Strategy is a good example of a design pattern that can be simpler in Python if you leverage functions as first-class objects. In the following section, we describe and implement Strategy using the “classic” structure described in Design Patterns. If you are familiar with the classic pattern, you can skip to “Function-Oriented Strategy” where we refactor the code using functions, significantly reducing the line count. Classic Strategy The UML class diagram in Figure 10-1 depicts an arrangement of classes that exemplifies the Strategy pattern.",0.11204483,
q009,refactoring strategy for functions doing IO and business logic together,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1376_c1,i. A Parameterized Registration Decorator ii. The Parameterized Clock Decorator iii. A class-based clock decorator k. Chapter Summary l. Further Reading 14. 10. Design Patterns with First-Class Functions a. What’s new in this chapter b. Case Study: Refactoring Strategy i. Classic Strategy ii. Function-Oriented Strategy iii. Choosing the Best Strategy: Simple Approach iv. Finding Strategies in a Module c. Decorator-Enhanced Strategy Pattern d. The Command Pattern e. Chapter Summary f. Further Reading 15. IV. Classes and Protocols 16. 11. A Pythonic Object a. What’s new in this chapter b. Object Representations c. Vector Class Redux d. An Alternative Constructor,0.100681625,
q009,refactoring strategy for functions doing IO and business logic together,sparse,3,cc_knowledge_book.pdf:p397_c2,"Limited); 33 * Contributor(s): -; 34 * 35 * $Id: SerialDateTests.java,v 1.6 2005/11/16 15:58:40 taqua Exp $ 36 * 37 * Changes 38 * ------- 39 * 15-Nov-2001 : Version 1 (DG); 40 * 25-Jun-2002 : Removed unnecessary import (DG); 41 * 24-Oct-2002 : Fixed errors reported by Checkstyle (DG); 42 * 13-Mar-2003 : Added serialization test (DG); 43 * 05-Jan-2005 : Added test for bug report 1096282 (DG); 44 * 45 */ 46 47 package org.jfree.date.junit; 48 49 import java.io.ByteArrayInputStream; 50 import java.io.ByteArrayOutputStream; 51 import java.io.ObjectInput; 52 import java.io.ObjectInputStream; 53 import java.io.ObjectOutput; 54 import java.io.ObjectOutputStream; 55 56 import junit.framework.Test; 57 import junit.framework.TestCase; 58 import junit.framework.TestSuite; 59 60 import org.jfree.date.MonthConstants; 61 import org.jfree.date.SerialDate; 62",0.069560766,
q009,refactoring strategy for functions doing IO and business logic together,sparse,4,cc_knowledge_book.pdf:p377_c1,"346 Appendix A: Concurrency II Client/Server Using Threads Changing the server to use threads simply requires a change to the process message (new lines are emphasized to stand out): void process(final Socket socket) { if (socket == null) return; Runnable clientHandler = new Runnable() { public void run() { } catch (IOException ignore) { } } private void closeIgnoringException(ServerSocket serverSocket) { if (serverSocket != null) try { serverSocket.close(); } catch (IOException ignore) { } } } Listing A-5 MessageUtils.java package common; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.net.Socket; public class MessageUtils { public static void sendMessage(Socket socket, String message) throws IOException { OutputStream stream = socket.getOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(stream); oos.writeUTF(message); oos.flush(); } public static String getMessage(Socket socket) throws IOException { InputStream stream = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(stream); return ois.readUTF(); } } Listing A-4 (continued) ClientTest.java",0.052095488,
q009,refactoring strategy for functions doing IO and business logic together,sparse,5,cc_knowledge_book.pdf:p191_c1,"160 Chapter 11: Systems I haven’t shown the corresponding LocalHome interface, essentially a factory used to create objects, nor any of the possible Bank ﬁnder (query) methods you might add. Finally, you had to write one or more XML deployment descriptors that specify the object-relational mapping details to a persistence store, the desired transactional behavior, security constraints, and so on. The business logic is tightly coupled to the EJB2 application “container.” Y ou must subclass container types and you must provide many lifecycle methods that are required by the container. Because of this coupling to the heavyweight container, isolated unit testing is difﬁcult. It is necessary to mock out the container, which is hard, or waste a lot of time deploying EJBs and tests to a real server. Reuse outside of the EJB2 architecture is effectively impos- sible, due to the tight coupling. Finally, even object-oriented programming is undermined. One bean cannot inherit from another bean. Notice the logic for adding a new account. It is common in EJB2 beans to deﬁne “data transfer objects” (DTOs) that are essentially “structs” with no behavior. This usually leads to redundant types holding essentially the same data, and it requires boilerplate code to copy data from one object to another. Cross-Cutting Concerns The EJB2 architecture comes close to true separation of concerns in some areas. For example, the desired transactional, security, and some of the persistence behaviors are declared in the deployment descriptors, independently of the source code. Note that concerns like persistence tend to cut across the natural object boundaries of a domain. Y ou want to persist all your objects using generally the same strategy, for exam- ple, using a particular DBMS 6 versus ﬂat ﬁles, following certain naming conventions for tables and columns, using consistent transactional semantics, and so on.",0.051037256,
q010,how to remove tight coupling between components in python applications,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p190_c1,"s.clear() ● Remove all elements of s s.copy() ● ● Shallow copy of s s.discard(e)● Remove element e from s if it is present s.__iter__()● ● Get iterator over s s.__len__()● ● len(s) s.pop() ● Remove and return an element from s, raising KeyError if s is empty s.remove(e)● Remove element e from s, raising Key Error if e not in s This completes our overview of the features of sets. As promised in “Dictionary views”, we’ll now see how two of the dictionary view types behave very much like a frozenset. Set operations on dict views Table 3-5 shows that the view objects returned by the dict methods .keys() and .items() are remarkably similar to frozenset.",0.07406711,
q010,how to remove tight coupling between components in python applications,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p241_c1,"Only the letters “è”, “ç”, and “í” were replaced. Both “έ” and “é” were replaced. The function shave_marks from Example 4-14 works all right, but maybe it goes too far. Often the reason to remove diacritics is to change Latin text to pure ASCII, but shave_marks also changes non-Latin characters—like Greek letters—which will never become ASCII just by losing their accents. So it makes sense to analyze each base character and to remove attached marks only if the base character is a letter from the Latin alphabet. This is what Example 4-16 does. Example 4-16. Function to remove combining marks from Latin characters (import statements are omitted as this is part of the simplify.py module from Example 4-14) def shave_marks_latin(txt): """"""Remove all diacritic marks from Latin base characters"""""" norm_txt = unicodedata.normalize('NFD', txt) latin_base = False preserve = [] for c in norm_txt: if unicodedata.combining(c) and latin_base: continue # ignore diacritic on Latin base char preserve.append(c) # if it isn't a combining char, it's a new base char if not unicodedata.combining(c): latin_base = c in string.ascii_letters shaved = ''.join(preserve) return unicodedata.normalize('NFC', shaved) Decompose all characters into base characters and combining marks. Skip over combining marks when base character is Latin. Otherwise, keep current character. Detect new base character and determine if it’s Latin. Recompose all characters.",0.07153829,
q010,how to remove tight coupling between components in python applications,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p486_c1,"Show float and Decimal with an approximate fractional equivalent. Function singledispatch Because we don’t have Java-style method overloading in Python, we can’t simply create variations of htmlize with different signatures for each data type we want to handle differently. A possible solution in Python would be to turn htmlize into a dispatch function, with a chain of if/elif/… or match/case/… calling specialized functions like htmlize_str, htmlize_int, etc. This is not extensible by users of our module, and is unwieldy: over time, the htmlize dispatcher would become too big, and the coupling between it and the specialized functions would be very tight. The functools.singledispatch decorator allows different modules to contribute to the overall solution, and lets you easily provide a specialized functions even for types that belong to third party packages that you can’t edit. If you decorate a plain function with @singledispatch, it becomes the entry point for a generic function: a group of functions to perform the same operation in different ways, depending on the type of the first argument. This is what is meant by the term single-dispatch. If more arguments were used to select the specific functions, we’d have multiple- dispatch. Example 9-20 shows how. WARNING functools.singledispatch exists since Python 3.4, but it only supports type hints since Python 3.7. The last two functions in Example 9-20 illustrate the syntax that works in all versions of Python since 3.4. Example 9-20. @singledispatch creates a custom @htmlize.register to bundle several functions into a generic function from functools import singledispatch from collections import abc import fractions",0.068052925,
q010,how to remove tight coupling between components in python applications,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p734_c1,"3; Mixins considered harmful, part 1 and part 2; and Things to Know About Python Super, part 1, part 2 and part 3. The oldest posts use the Python 2 super syntax, but are still relevant. I read the first edition of Grady Booch’s Object-Oriented Analysis and Design, 3E (Addison-Wesley, 2007), and highly recommend it as a general primer on object-oriented thinking, independent of programming language. It is a rare book that covers multiple inheritance without prejudice. In 2021, it’s more fashionable than ever to avoid inheritance, so here are two references about how to do that. Brandon Rhodes wrote The Composition Over Inheritance Principle, part of his excellent Python Design Patterns guide on the Web. Augie Fackler and Nathaniel Manista presented The End Of Object Inheritance & The Beginning Of A New Modularity at PyCon 2013—that was before I wrote the first edition, but I only found it in 2019. Fackler and Manista talk about organizing systems around interfaces and functions that handle objects implementing those interfaces, avoiding the tight coupling and failure modes of classes and inheritance. That reminds me a lot of the Go way, but they advocate it for Python.",0.061176486,
q010,how to remove tight coupling between components in python applications,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p582_c1,"def __repr__(self): components = reprlib.repr(self._components) components = components[components.find('['):-1] return f'Vector({components})' def __str__(self): return str(tuple(self)) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(self._components)) def __eq__(self, other): return tuple(self) == tuple(other) def __abs__(self): return math.hypot(*self) def __bool__(self): return bool(abs(self)) @classmethod def frombytes(cls, octets): typecode = chr(octets[0]) memv = memoryview(octets[1:]).cast(typecode) return cls(memv) The self._components instance “protected” attribute will hold an array with the Vector components. To allow iteration, we return an iterator over self._components. Use reprlib.repr() to get a limited-length representation of self._components (e.g., array('d', [0.0, 1.0, 2.0, 3.0, 4.0, ...])). Remove the array('d', prefix and the trailing ) before plugging the string into a Vector constructor call. Build a bytes object directly from self._components. 1",0.059906974,
q011,best practices for organizing utility functions in python projects,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p259_c2,"syntax details, codecs, regular expressions, filenames, and best practices for Unicode- aware I/O (i.e., the Unicode sandwich), with plenty of additional reference links from each section. Chapter 4, “Strings”, of Mark Pilgrim’s awesome book Dive into Python 3 also provides a very good intro to Unicode support in Python 3. In the same book, Chapter 15 describes how the Chardet library was ported from Python 2 to Python 3, a valuable case study given that the switch from the old str to the new bytes is the cause of most",0.10664666,
q011,best practices for organizing utility functions in python projects,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p238_c1,">>> eszett, eszett_cf ('ß', 'ss') There are nearly 300 code points for which str.casefold() and str.lower() return different results. As usual with anything related to Unicode, case folding is a hard issue with plenty of linguistic special cases, but the Python core team made an effort to provide a solution that hopefully works for most users. In the next couple of sections, we’ll put our normalization knowledge to use developing utility functions. Utility Functions for Normalized Text Matching As we’ve seen, NFC and NFD are safe to use and allow sensible comparisons between Unicode strings. NFC is the best normalized form for most applications. str.casefold() is the way to go for case-insensitive comparisons. If you work with text in many languages, a pair of functions like nfc_equal and fold_equal in Example 4-13 are useful additions to your toolbox. Example 4-13. normeq.py: normalized Unicode string comparison """""" Utility functions for normalized Unicode string comparison. Using Normal Form C, case sensitive: >>> s1 = 'café' >>> s2 = 'cafe\u0301' >>> s1 == s2 False >>> nfc_equal(s1, s2) True >>> nfc_equal('A', 'a') False Using Normal Form C with case folding: >>> s3 = 'Straße'",0.099735446,
q011,best practices for organizing utility functions in python projects,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p203_c1,"Unique features of binary sequences: bytes, bytearray, and memoryview Encodings for full Unicode and legacy character sets Avoiding and dealing with encoding errors Best practices when handling text files The default encoding trap and standard I/O issues Safe Unicode text comparisons with normalization Utility functions for normalization, case folding, and brute-force diacritic removal Proper sorting of Unicode text with locale and the PyUCA library Character metadata in the Unicode database Dual-mode APIs that handle str and bytes What’s new in this chapter Support for Unicode in Python 3 has been comprehensive and stable, so the most notable addition is is “Finding characters by name”, describing a utility for searching the Unicode database—a great way to find circled digits and smiling cats from the command-line. One minor change worth mentioning is the Unicode support on Windows, which is better and simpler since Python 3.6, as we’ll see in “Beware of Encoding Defaults”. Let’s start with the not-so-new, but fundamental concepts of characters, code points, and bytes.",0.09076341,
q011,best practices for organizing utility functions in python projects,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p259_c1,"leveraging the standard locale module—with some caveats—and an alternative that does not depend on tricky locale configurations: the external PyUCA package. We leveraged the Unicode database to program a command-line utility to search for characters by name–in 28 lines of code, thanks to the power of Python. We glanced at other Unicode metadata, and had a brief overview of dual-mode APIs where some functions can be called with str or bytes arguments, producing different results. Further Reading Ned Batchelder’s 2012 PyCon US talk “Pragmatic Unicode–or–How Do I Stop the Pain?” was outstanding. Ned is so professional that he provides a full transcript of the talk along with the slides and video. “Character encoding and Unicode in Python: How to ( ╯ °□°) ╯ ︵ ┻━┻ with dignity” (slides, video) was the excellent PyCon 2014 talk by Esther Nam and Travis Fischer where I found this chapter’s pithy epigraph: “Humans use text. Computers speak bytes.” Lennart Regebro—one of the technical reviewers for the First Edition-- shares his “Useful Mental Model of Unicode (UMMU)” in the short post “Unconfusing Unicode: What Is Unicode?”. Unicode is a complex standard, so Lennart’s UMMU is a really useful starting point. The official Unicode HOWTO in the Python docs approaches the subject from several different angles, from a good historic intro to syntax details, codecs, regular expressions, filenames, and best practices for Unicode- aware I/O (i.e., the Unicode sandwich), with plenty of additional reference links from each section. Chapter 4, “Strings”, of Mark Pilgrim’s awesome book Dive into Python 3 also provides a very good intro to Unicode support in Python 3.",0.06996868,
q011,best practices for organizing utility functions in python projects,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p498_c1,"Chapter Summary We covered some difficult terrain in this chapter. I tried to make the journey as smooth as possible, but we definitely entered the realm of metaprogramming. We started with a simple @register decorator without an inner function, and finished with a parameterized @clock() involving two levels of nested functions. Registration decorators, though simple in essence, have real applications in Python frameworks. We will apply the registration idea in one implementation of the Strategy design pattern in Chapter 10. Understanding how decorators actually work required covering the difference between import time and runtime, then diving into variable scoping, closures, and the new nonlocal declaration. Mastering closures and nonlocal is valuable not only to build decorators, but also to code event-oriented programs for GUIs or asynchronous I/O with callbacks, and to adopt a functional style when it makes sense. Parameterized decorators almost always involve at least two nested functions, maybe more if you want to use @functools.wraps to produce a decorator that provides better support for more advanced techniques. One such technique is stacked decorators, which we saw in Example 9-18. For more sophisticated decorators, a class-based implementation may be easier to read and maintain. As examples of parametrized decorators in the standard library, we visited the powerful @cache and @singledispatch from the functools module. Further Reading Item #26 of Brett Slatkin’s Effective Python, Second Edition (Addison- Wesley, 2019) covers best practices for function decorators and",0.065651044,
q012,refactor excessive boolean flags in function signatures,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1109_c1,"environment, I recommend configuring Nginx and toxiproxy with equivalent parameters. By default, each flags2*.py script will fetch the flags of the 20 most populous countries from the LOCAL server (http://localhost:8000/flags) using a default number of concurrent connections, which varies from script to script. Example 21-11 shows a sample run of the flags2_sequential.py script using all defaults. Example 21-11. Running flags2_sequential.py with all defaults: LOCAL site, top-20 flags, 1 concurrent connection $ python3 flags2_sequential.py LOCAL site: http://localhost:8000/flags Searching for 20 flags: from BD to VN 1 concurrent connection will be used. -------------------- 20 flags downloaded. Elapsed time: 0.10s You can select which flags will be downloaded in several ways. Example 21-12 shows how to download all flags with country codes starting with the letters A, B, or C. Example 21-12. Run flags2_threadpool.py to fetch all flags with country codes prefixes A, B, or C from DELAY server $ python3 flags2_threadpool.py -s DELAY a b c DELAY site: http://localhost:8001/flags Searching for 78 flags: from AA to CZ 30 concurrent connections will be used. -------------------- 43 flags downloaded. 35 not found. Elapsed time: 1.72s Regardless of how the country codes are selected, the number of flags to fetch can be limited with the -l/--limit option. Example 21-13 demonstrates how to run exactly 100 requests, combining the -a option to get all flags with -l 100.",0.15138598,
q012,refactor excessive boolean flags in function signatures,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1082_c2,"MacOS Finder window displays the flags as they are saved. The scripts are downloading images from fluentpython.com, which is behind a CDN, so you may see slower results in the first runs. The results in Example 21-1 were obtained after several runs, so the CDN cache was warm. Example 21-1. Three typical runs of the scripts flags.py, flags_threadpool.py, and flags_asyncio.py $ python3 flags.py BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN 20 flags downloaded in 7.26s $ python3 flags.py BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN 20 flags downloaded in 7.20s $ python3 flags.py BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN 20 flags downloaded in 7.09s $ python3 flags_threadpool.py DE BD CN JP ID EG NG BR RU CD IR MX US PH FR PK VN IN ET TR 20 flags downloaded in 1.37s $ python3 flags_threadpool.py EG BR FR IN BD JP DE RU PK PH CD MX ID US NG TR CN VN ET IR 20 flags downloaded in 1.60s $ python3 flags_threadpool.py BD DE EG CN ID RU IN VN ET MX FR CD NG US JP TR PK BR IR PH 20 flags downloaded in 1.22s $ python3 flags_asyncio.py BD BR IN ID TR DE CN US IR PK PH FR RU NG VN ET MX EG JP CD 20 flags downloaded in 1.36s $ python3 flags_asyncio.py",0.080313034,
q012,refactor excessive boolean flags in function signatures,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p375_c1,"arguments when defining a function, name them after the argument prefixed with *. If you don’t want to support variable positional arguments but still want keyword-only arguments, put a * by itself in the signature, like this: >>> def f(a, *, b): ... return a, b ... >>> f(1, b=2) (1, 2) >>> f(1, 2) Traceback (most recent call last): File ""<stdin>"", line 1, in <module> TypeError: f() takes 1 positional argument but 2 were given Note that keyword-only arguments do not need to have a default value: they can be mandatory, like b in the preceding example. Positional-only parameters Since Python 3.8, user-defined function signatures may specify positional- only parameters. This feature always existed for built-in functions, such as divmod(a, b), which can only be called with positional parameters, and not as divmod(a=10, b=4). To define a function requiring positional-only parameters, use / in the parameter list. This example from What’s New In Python 3.8 shows how to emulate the divmod built-in function: def divmod(a, b, /): return (a // b, a % b) All arguments to the left of the / are positional-only. After the /, you may specify other arguments, which work as usual.",0.07503696,
q012,refactor excessive boolean flags in function signatures,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p440_c1,"perform console experiments to find out that sorted only requires that the elements support <. Now we can make duck typing explicit for static type checkers. That’s why it makes sense to say that typing.Protocol gives us static duck typing. There’s more to see about typing.Protocol. We’ll come back to it in Part IV, where Chapter 13 contrasts structural typing, duck typing, and ABCs—another approach to formalizing protocols. In addition, “Overloaded signatures” (Chapter 15) explains how to declare overloaded function signatures with @typing.overload, and includes an extensive example using typing.Protocol and a bounded TypeVar. NOTE typing.Protocol makes it possible to annotate the double function presented in “Types are defined by supported operations” without losing functionality. The key is to define a protocol class with the __mul__ method. I invite you to do that as an exercise. The solution appears in “The typed double function” (Chapter 13). Callable To annotate callback parameters or function objects returned by higher- order functions, the typing module provides the Callable type, which is parameterized like this: Callable[[ParamType1, ParamType2], ReturnType] The parameter list—[ParamType1, ParamType2]—can have 0 or more types. Here is an example in context: def repl(input_fn: Callable[[Any], str] = input) -> None: The repl function is part of a simple interactive interpreter. 17 18",0.07256208,
q012,refactor excessive boolean flags in function signatures,sparse,5,cc_knowledge_book.pdf:p243_c2,"ruin a program is to make massive changes to its structure in the name of improvement. Some programs never recover from such “improvements.” The problem is that it’s very hard to get the program working the same way it worked before the “improvement.” public boolean getBoolean(char arg) { return falseIfNull(booleanArgs.get(arg)); } private boolean falseIfNull(Boolean b) { return b == null ? false : b; } public String getString(char arg) { return blankIfNull(stringArgs.get(arg)); } private String blankIfNull(String s) { return s == null ? """" : s; } public boolean has(char arg) { return argsFound.contains(arg); } public boolean isValid() { return valid; } } Listing 14-10 (continued) Args.java (Boolean and String)",0.066928655,
q013,replace long switch or if chains with polymorphism patterns,sparse,1,cc_knowledge_book.pdf:p68_c2,"they do “one thing.” Making the code read like a top-down set of TO paragraphs is an effective technique for keeping the abstraction level consistent. Take a look at Listing 3-7 at the end of this chapter. It shows the whole testableHtml function refactored according to the principles described here. Notice how each function introduces the next, and each function remains at a consistent level of abstraction. Switch Statements It’ s hard to make a small switch statement.6 Even a switch statement with only two cases is larger than I’ d like a single block or function to be. It’ s also hard to make a switch state- ment that does one thing. By their nature, switch statements always do N things. Unfortu- nately we can’t always avoid switch statements, but we can make sure that each switch statement is buried in a low-level class and is never repeated. We do this, of course, with polymorphism. 5. [KP78], p. 37. 6. And, of course, I include if/else chains in this.",0.1843702,
q013,replace long switch or if chains with polymorphism patterns,sparse,2,cc_knowledge_book.pdf:p330_c1,"299General This code has a logical dependency that has not been physicalized. Can you spot it? It is the constant PAGE_SIZE. Why should the HourlyReporter know the size of the page? Page size should be the responsibility of the HourlyReportFormatter. The fact that P AGE_SIZE is declared in HourlyReporter represents a misplaced responsibility [G17] that causes HourlyReporter to assume that it knows what the page size ought to be. Such an assumption is a logical dependency. HourlyReporter depends on the fact that HourlyReportFormatter can deal with page sizes of 55. If some implementation of HourlyReportFormatter could not deal with such sizes, then there would be an error. We can physicalize this dependency by creating a new method in HourlyReport- Formatter named getMaxPageSize(). HourlyReporter will then call that function rather than using the PAGE_SIZE constant. G23: Prefer Polymorphism to If/Else or Switch/Case This might seem a strange suggestion given the topic of Chapter 6. After all, in that chapter I make the point that switch statements are probably appropriate in the parts of the system where adding new functions is more likely than adding new types. First, most people use switch statements because it’ s the obvious brute force solution, not because it’ s the right solution for the situation. So this heuristic is here to remind us to consider polymorphism before using a switch. Second, the cases where functions are more volatile than types are relatively rare. So every switch statement should be suspect. I use the following “O NE SWITCH” rule: There may be no more than one switch state- ment for a given type of selection. The cases in that switch statement must create polymor- phic objects that take the place of other such switch statements in the rest of the system. G24:",0.11833294,
q013,replace long switch or if chains with polymorphism patterns,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p505_c1,"Chapter 10. Design Patterns with First-Class Functions A NOTE FOR EARLY RELEASE READERS With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles. This will be the 10th chapter of the final book. Please note that the GitHub repo will be made active later on. If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at fluentpython2e@ramalho.org. Conformity to patterns is not a measure of goodness. —Ralph Johnson, Coauthor of the Design Patterns classic In software engineering, a design pattern is a general recipe for solving a common design problem. You don’t need to know design patterns to follow this chapter. I will explain the patterns used in the examples. The use of design patterns in programming was popularized by the landmark book Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley, 1995) by Erich Gamma, Richard Helm, Ralph Johnson & John Vlissides—a.k.a. “the Gang of Four.” The book is a catalog of 23 patterns consisting of arrangements of classes exemplified with code in C++, but assumed to be useful in other Object-Oriented languages as well. 1",0.09392382,
q013,replace long switch or if chains with polymorphism patterns,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p506_c1,"Although design patterns are language-independent, that does not mean every pattern applies to every language. For example, Chapter 17 will show that it doesn’t make sense to emulate the recipe of the Iterator pattern in Python, because the pattern is embedded in the language and ready to use in in the form of generators—which don’t need classes to work, and require less code than the classic recipe. The authors of Design Patterns acknowledge in their Introduction that the implementation language determines which patterns are relevant: The choice of programming language is important because it influences one’s point of view. Our patterns assume Smalltalk/C++-level language features, and that choice determines what can and cannot be implemented easily. If we assumed procedural languages, we might have included design patterns called “Inheritance,” “Encapsulation,” and “Polymorphism.” Similarly, some of our patterns are supported directly by the less common object-oriented languages. CLOS has multi-methods, for example, which lessen the need for a pattern such as Visitor. In his 1996 presentation, “Design Patterns in Dynamic Languages”, Peter Norvig states that 16 out of the 23 patterns in the original Design Patterns book become either “invisible or simpler” in a dynamic language (slide 9). He was talking about the Lisp and Dylan languages, but many of the relevant dynamic features are also present in Python. In particular, in the context of languages with first-class functions, Norvig suggests rethinking the classic patterns known as Strategy, Command, Template Method, and Visitor. The goal of this chapter is to show how—in some cases—functions can do the same work as classes, with code that is shorter and easier to read. We will refactor an implementation of Strategy using functions as objects, removing a lot of boilerplate code. We’ll also discuss a similar approach to simplifying the Command pattern.",0.08371792,
q013,replace long switch or if chains with polymorphism patterns,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p530_c1,"SOAPBOX Python has first-class functions and first-class types, features that Norvig claims affect 10 of the 23 patterns (slide 10 of Design Patterns in Dynamic Languages). In the Chapter 9, we saw that Python also has generic functions (“Single Dispatch Generic Functions”), a limited form of the CLOS multimethods that Gamma et al. suggest as a simpler way to implement the classic Visitor pattern. Norvig, on the other hand, says that multimethods simplify the Builder pattern (slide 10). Matching design patterns to language features is not an exact science. In classrooms around the world, design patterns are frequently taught using Java examples. I’ve heard more than one student claim that they were led to believe that the original design patterns are useful in any implementation language. It turns out that the “classic” 23 patterns from the Gamma et al. book apply to “classic” Java very well in spite of being originally presented mostly in the context of C++—a few have Smalltalk examples in the book. But that does not mean every one of those patterns applies equally well in any language. The authors are explicit right at the beginning of their book that “some of our patterns are supported directly by the less common object-oriented languages” (recall full quote on first page of this chapter). The Python bibliography about design patterns is very thin, compared to that of Java, C++, or Ruby. In “Further Reading” I mentioned Learning Python Design Patterns by Gennadiy Zlobin, which was published as recently as November 2013. In contrast, Russ Olsen’s Design Patterns in Ruby was published in 2007 and has 384 pages— 284 more than Zlobin’s work. Now that Python is becoming increasingly popular in academia, let’s hope more will be written about design patterns in the context of this language.",0.073673286,
q014,identify and eliminate dead code in python codebases,sparse,1,cc_knowledge_book.pdf:p323_c1,"292 Chapter 17: Smells and Heuristics Good software developers learn to limit what they expose at the interfaces of their classes and modules. The fewer methods a class has, the better. The fewer variables a func- tion knows about, the better. The fewer instance variables a class has, the better. Hide your data. Hide your utility functions. Hide your constants and your temporaries. Don’t create classes with lots of methods or lots of instance variables. Don’t create lots of protected variables and functions for your subclasses. Concentrate on keeping interfaces very tight and very small. Help keep coupling low by limiting information. G9: Dead Code Dead code is code that isn’t executed. Y ou ﬁnd it in the body of an if statement that checks for a condition that can’t happen. Y ou ﬁnd it in the catch block of a try that never throws. Y ou ﬁnd it in little utility methods that are never called or switch/case conditions that never occur. The problem with dead code is that after awhile it starts to smell. The older it is, the stronger and sourer the odor becomes. This is because dead code is not completely updated when designs change. It still compiles, but it does not follow newer conventions or rules. It was written at a time when the system was different. When you ﬁnd dead code, do the right thing. Give it a decent burial. Delete it from the system. G10: V ertical Separation Variables and function should be deﬁned close to where they are used. Local variables should be declared just above their ﬁrst usage and should have a small vertical scope. We don’t want local variables declared hundreds of lines distant from their usages. Private functions should be deﬁned just below their ﬁrst usage.",0.1647706,
q014,identify and eliminate dead code in python codebases,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p695_c2,"valuable enough to attract investment and adoption by companies with very large Python codebases, like Dropbox, Google, and Facebook—as well as support from professional IDEs like PyCharm, Wing, and VS Code. PEP 526—Syntax for Variable Annotations was the first evolutionary step that required changes to the interpreter, in Python 3.6. Further changes to the interpreter were made in Python 3.7 to support PEP 563 —Postponed Evaluation of Annotations and PEP 560—Core support for typing module and generic types—which in turn allowed built-in and standard library collections to accept generic type hints out of the",0.08703746,
q014,identify and eliminate dead code in python codebases,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p389_c1,"Chapter 8. Type Hints in Functions A NOTE FOR EARLY RELEASE READERS With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles. This will be the 8th chapter of the final book. Please note that the GitHub repo will be made active later on. If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at fluentpython2e@ramalho.org. It should also be emphasized that Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention. —Guido van Rossum, Jukka Lehtosalo, and Łukasz Langa, PEP 484—Type Hints Type hints are the biggest change in the history of Python since the unification of types and classes in Python 2.2, released in 2001. However, type hints do not benefit all Python users equally. That’s why they should always be optional. PEP 484—Type Hints introduced syntax and semantics for explicit type declarations in function arguments, return values, and variables. The goal is to help developer tools find bugs in Python codebases via static analysis, i.e. without actually running the code through tests. 1",0.065852165,
q014,identify and eliminate dead code in python codebases,sparse,4,cc_knowledge_book.pdf:p15_c1,"xiv Contents Chapter 15: JUnit Internals..........................................................251 The JUnit Framework.......................................................................252 Conclusion..........................................................................................265 Chapter 16: Refactoring SerialDate.........................................267 First, Make It Work...........................................................................268 Then Make It Right...........................................................................270 Conclusion..........................................................................................284 Bibliography.......................................................................................284 Chapter 17: Smells and Heuristics .............................................285 Comments ..........................................................................................286 C1: Inappropriate Information.......................................................286 C2: Obsolete Comment...................................................................286 C3: Redundant Comment ...............................................................286 C4: Poorly Written Comment..........................................................287 C5: Commented-Out Code .............................................................287 Environment......................................................................................287 E1: Build Requires More Than One Step........................................287 E2: Tests Require More Than One Step..........................................287 Functions............................................................................................288 F1: Too Many Arguments................................................................288 F2: Output Arguments ....................................................................288 F3: Flag Arguments........................................................................288 F4: Dead Function .........................................................................288 General...............................................................................................288 G1: Multiple Languages in One Source File..................................288 G2: Obvious Behavior Is Unimplemented......................................288 G3: Incorrect Behavior at the Boundaries.....................................289 G4: Overridden Safeties.................................................................289 G5: Duplication..............................................................................289 G6: Code at Wrong Level of Abstraction........................................290 G7: Base Classes Depending on Their Derivatives .......................291 G8: Too Much Information.............................................................291 G9: Dead Code...............................................................................292 G10: V ertical Separation................................................................292 G11: Inconsistency .........................................................................292 G12: Clutter....................................................................................293",0.059742864,
q014,identify and eliminate dead code in python codebases,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p695_c1,"SOAPBOX The MVP Journey of Python Static Typing I work for Thoughtworks, a worldwide leader in agile software development. At Thoughtworks, we often recommend that our clients should aim to create and deploy MVPs: minimal viable products— “a simple version of a product that is given to users in order to validate the key business assumptions” as defined by my colleague Paulo Caroli in Lean Inception, a post in Martin Fowler’s collective blog. Guido van Rossum and the other core developers who designed and implemented static typing have followed an MVP strategy since 2006. First, PEP 3107—Function Annotations was implemented in Python 3.0 with very limited semantics: just syntax to attach annotations to function arguments and returns. This was done explicitly to allow for experimentation and collect feedback—key benefits of an MVP. Eight years later, PEP 484—Type Hints was proposed and approved. Its implementation in Python 3.5 required no changes in the language or standard library—except the addition of the typing module, on which no other part of the standard library depended. PEP 484 supported only nominal types with generics—similar to Java—but with the actual static checking done by external tools. Important features—like variable annotations, generic built-in types, and static protocols—were missing. Despite those limitations, this typing MVP was valuable enough to attract investment and adoption by companies with very large Python codebases, like Dropbox, Google, and Facebook—as well as support from professional IDEs like PyCharm, Wing, and VS Code. PEP 526—Syntax for Variable Annotations was the first evolutionary step that required changes to the interpreter, in Python 3.6.",0.059365988,
q015,refactoring large dictionary-driven functions with complex rules,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p677_c1,">>> complex(c) (3+4j) complex64 is one of five complex number types provided by NumPy. None of the NumPy complex types subclass the built-in complex. But NumPy’s complex types implement __complex__ so they comply with the SupportsComplex protocol. Therefore, you can create built-in complex objects from them. Sadly, the complex built-in type does not implement __complex__ although complex(c) works fine if c is a complex. As a result of that last point, if you want to test whether an object c is a complex or SupportsComplex you can provide a tuple of types as the second argument to isinstance, like this: isinstance(c, (complex, SupportsComplex)) An alternative would be to use the Complex ABC, defined in the numbers module. The built-in complex type and the NumPy complex64 and complex128 types are all registered as virtual subclasses of numbers.Complex, therefore this works: >>> import numbers >>> isinstance(c, numbers.Complex) True >>> isinstance(c64, numbers.Complex) True I recommended using the numbers ABCs in Fluent Python, First Edition but now that’s no longer good advice, because those ABCs are not recognized by the static type checkers, as we’ll see in “The numbers ABCs and numeric protocols”.",0.1534427,
q015,refactoring large dictionary-driven functions with complex rules,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p679_c1,"DUCK TYPING IS YOUR FRIEND Very often at runtime, duck typing is the best approach for type checking: instead of calling isinstance or hasattr, just try the operations you need to do on the object, and handle exceptions as needed. Here is a concrete example. Continuing the previous discussion—given an object o that I need to use as a complex number, this would be one approach: if isinstance(o, (complex, SupportsComplex)): # do something that requires `o` to be convertible to complex else: raise TypeError('o must be convertible to complex') The goose typing approach would be to use the numbers.Complex ABC: if isinstance(o, numbers.Complex): # do something with `o`, an instance of `Complex` else: raise TypeError('o must be an instance of Complex') However, I prefer to leverage duck typing and do this, using the EAFP principle—it’s easier to ask forgiveness than permission: try: c = complex(o) except TypeError as exc: raise TypeError('o must be convertible to complex') from exc And, if all you’re going to do is raise a TypeError anyway, then I’d omit the try/except/raise statements and just write this: c = complex(o)",0.11134375,
q015,refactoring large dictionary-driven functions with complex rules,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p411_c1,"Abstract Base Classes are also useful in type hints. We’ll get back to them as we study collection types, and in “Abstract Base Classes”. Among classes, is consistent-with is defined like is subtype-of: a subclass is consistent-with all its superclasses. However, “practicality beats purity” so there is an important exception: INT IS C O N S I S T E N T - W I T H COMPLEX There is no nominal subtype relationship between the built-in types int, float and complex: they are direct subclasses of object. But PEP 484 declares that int is consistent-with float, and float is consistent-with complex. It makes sense in practice: int implements all operations that float does, and int implements additional ones as well—bitwise operations like &, |, << etc. The end result is: int is consistent-with complex. For i = 3, i.real is 3, and i.imag is 0. Optional and Union types We saw the Optional special type in “Using None as a default”. It solves the problem of having None as a default, as in this example from that section: from typing import Optional def show_count(count: int, singular: str, plural: Optional[str] = None) -> str: The construct Optional[str] is actually a shortcut for Union[str, None] which means the type of plural may be str or None. The ord built-in function’s signature is a simple example of Union—it accepts str or bytes, and returns an int: def ord(c: Union[str, bytes]) -> int: ... 8",0.0914776,
q015,refactoring large dictionary-driven functions with complex rules,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p690_c1,">>> [complex(x) for x in sample] [(1+0j), (1+0j), (1+0j), (1+0j), (1+0j), (1+0j)] This shows that isinstance checks against SupportsComplex suggest those conversions to complex would fail, but they all succeed. In the typing-sig mailing list, Guido pointed out that the built-in complex accepts a single argument, and that’s why those conversions work. On the other hand, Mypy accepts arguments of all those six types in a call to a to_complex() function defined like this: def to_complex(n: SupportsComplex) -> complex: return complex(n) As I write this, NumPy has no type hints, so its number types are all Any. On the other hand, Mypy is somehow “aware” that the built-in int and float can be converted to complex, even though on typeshed only the built-in complex class has a __complex__ method. In conclusion, although numeric types should not be hard to type check, the current situation is this: the type hints PEP-484 eschews the numeric tower and implicitly recommends that type checkers hard code the subtype relationships between built-in complex, float and int. Mypy does that, and also pragmatically accepts that int and float are consistent- with SupportsComplex, even though they don’t implement __complex__. TIP I only found unexpected results when using isinstance checks with numeric Supports* protocols while experimenting with conversions to or from complex. If you don’t use complex numbers, you can rely on those protocols instead of the numbers ABCs. The main takeaways for this section are: 24 25",0.089568265,
q015,refactoring large dictionary-driven functions with complex rules,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p680_c1,"In this last case, if o is not an acceptable type, Python will raise an exception with a very clear message: For example, this is what I get if o is a tuple: TypeError: complex() first argument must be a string or a number, not 'tuple' I find the duck typing approach much better in this case. Now that we’ve seen how to use static protocols at runtime with preexisting types like complex and numpy.complex64, let’s see how to use them with a user-defined class. Supporting a static protocol Recall the Vector2d class we built in Chapter 11. Given that a complex number and a Vector2d instance both consist of a pair of floats, it makes sense to support conversion from Vector2d to complex. Example 13-16 shows the implementation of the __complex__ method to enhance the last version of Vector2d we saw in Example 11-11. For completeness, we can support the inverse operation with a fromcomplex class method to build a Vector2d from a complex. Example 13-16. vector2d_v4.py: methods for converting to and from complex. def __complex__(self): return complex(self.x, self.y) @classmethod def fromcomplex(cls, datum): return cls(datum.real, datum.imag) This assumes that datum has .real and .imag attributes. We’ll see a better implementation in Example 13-17.",0.079702996,
q016,testing strategy for functions with side effects and global state,sparse,1,cc_knowledge_book.pdf:p344_c1,"313Tests vis_ (for visual imaging system) are distracting and redundant. Again, today’ s environ- ments provide all that information without having to mangle the names. Keep your names free of Hungarian pollution. N7: Names Should Describe Side-Effects Names should describe everything that a function, variable, or class is or does. Don’t hide side effects with a name. Don’t use a simple verb to describe a function that does more than just that simple action. For example, consider this code from TestNG: public ObjectOutputStream getOos() throws IOException { if (m_oos == null) { m_oos = new ObjectOutputStream(m_socket.getOutputStream()); } return m_oos; } This function does a bit more than get an “oos”; it creates the “oos” if it hasn’t been cre- ated already. Thus, a better name might be createOrReturnOos. Tests T1: Insufﬁcient Tests How many tests should be in a test suite? Unfortunately, the metric many programmers use is “That seems like enough.” A test suite should test everything that could possibly break. The tests are insufﬁcient so long as there are conditions that have not been explored by the tests or calculations that have not been validated. T2: Use a Coverage Tool! Coverage tools reports gaps in your testing strategy. They make it easy to ﬁnd modules, classes, and functions that are insufﬁciently tested. Most IDEs give you a visual indication, marking lines that are covered in green and those that are uncovered in red. This makes it quick and easy to ﬁnd if or catch statements whose bodies haven’t been checked. T3: Don’t Skip Trivial Tests They are easy to write and their documentary value is higher than the cost to produce them. T4: An Ignored Test Is a Question about an Ambiguity Sometimes we are uncertain about a behavioral detail because the requirements are unclear.",0.096095756,
q016,testing strategy for functions with side effects and global state,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p507_c1,"I moved this chapter to the end of Part III so I could apply a registration decorator in “Decorator-Enhanced Strategy Pattern” and also use type hints in the examples. Most type hints used in this chapter are not complicated, and they do help with readability. Case Study: Refactoring Strategy Strategy is a good example of a design pattern that can be simpler in Python if you leverage functions as first-class objects. In the following section, we describe and implement Strategy using the “classic” structure described in Design Patterns. If you are familiar with the classic pattern, you can skip to “Function-Oriented Strategy” where we refactor the code using functions, significantly reducing the line count. Classic Strategy The UML class diagram in Figure 10-1 depicts an arrangement of classes that exemplifies the Strategy pattern.",0.08675266,
q016,testing strategy for functions with side effects and global state,sparse,3,cc_knowledge_book.pdf:p75_c1,"44 Chapter 3: Functions Have No Side Effects Side effects are lies. Y our function promises to do one thing, but it also does other hidden things. Sometimes it will make unexpected changes to the variables of its own class. Sometimes it will make them to the parameters passed into the function or to system glo- bals. In either case they are devious and damaging mistruths that often result in strange temporal couplings and order dependencies. Consider, for example, the seemingly innocuous function in Listing 3-6. This function uses a standard algorithm to match a userName to a password. It returns true if they match and false if anything goes wrong. But it also has a side effect. Can you spot it? The side effect is the call to Session.initialize(), of course. The checkPassword func- tion, by its name, says that it checks the password. The name does not imply that it initial- izes the session. So a caller who believes what the name of the function says runs the risk of erasing the existing session data when he or she decides to check the validity of the user. This side effect creates a temporal coupling. That is, checkPassword can only be called at certain times (in other words, when it is safe to initialize the session). If it is called out of order, session data may be inadvertently lost. Temporal couplings are con- fusing, especially when hidden as a side effect. If you must have a temporal coupling, you should make it clear in the name of the function. In this case we might rename the function checkPasswordAndInitializeSession, though that certainly violates “Do one thing.” Listing 3-6 UserValidator.java public class UserValidator { private Cryptographer cryptographer; public boolean checkPassword(String userName, String password) { User user = UserGateway.findByName(userName);",0.08506916,
q016,testing strategy for functions with side effects and global state,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1376_c1,i. A Parameterized Registration Decorator ii. The Parameterized Clock Decorator iii. A class-based clock decorator k. Chapter Summary l. Further Reading 14. 10. Design Patterns with First-Class Functions a. What’s new in this chapter b. Case Study: Refactoring Strategy i. Classic Strategy ii. Function-Oriented Strategy iii. Choosing the Best Strategy: Simple Approach iv. Finding Strategies in a Module c. Decorator-Enhanced Strategy Pattern d. The Command Pattern e. Chapter Summary f. Further Reading 15. IV. Classes and Protocols 16. 11. A Pythonic Object a. What’s new in this chapter b. Object Representations c. Vector Class Redux d. An Alternative Constructor,0.06763317,
q016,testing strategy for functions with side effects and global state,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p509_c1,"Figure 10-1. UML class diagram for order discount processing implemented with the Strategy design pattern The Strategy pattern is summarized like this in Design Patterns: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. A clear example of Strategy applied in the ecommerce domain is computing discounts to orders according to the attributes of the customer or inspection of the ordered items. Consider an online store with these discount rules: Customers with 1,000 or more fidelity points get a global 5% discount per order. A 10% discount is applied to each line item with 20 or more units in the same order. Orders with at least 10 distinct items get a 7% global discount. For brevity, let’s assume that only one discount may be applied to an order. The UML class diagram for the Strategy pattern is depicted in Figure 10-1. Its participants are: Context Provides a service by delegating some computation to interchangeable components that implement alternative algorithms. In the ecommerce example, the context is an Order, which is configured to apply a promotional discount according to one of several algorithms. Strategy The interface common to the components that implement the different algorithms. In our example, this role is played by an abstract class called Promotion.",0.06642424,
q017,refactor large data transformation functions into smaller steps,sparse,1,cc_knowledge_book.pdf:p172_c1,"141Classes Should Be Small! get out of the larger class. Y ou should try to separate the variables and methods into two or more classes such that the new classes are more cohesive. Maintaining Cohesion Results in Many Small Classes Just the act of breaking large functions into smaller functions causes a proliferation of classes. Consider a large function with many variables declared within it. Let’ s say you want to extract one small part of that function into a separate function. However, the code you want to extract uses four of the variables declared in the function. Must you pass all four of those variables into the new function as arguments? Not at all! If we promoted those four variables to instance variables of the class, then we could extract the code without passing any variables at all. It would be easy to break the function up into small pieces. Unfortunately, this also means that our classes lose cohesion because they accumulate more and more instance variables that exist solely to allow a few functions to share them. But wait! If there are a few functions that want to share certain variables, doesn’t that make them a class in their own right? Of course it does. When classes lose cohesion, split them! So breaking a large function into many smaller functions often gives us the opportu- nity to split several smaller classes out as well. This gives our program a much better orga- nization and a more transparent structure. As a demonstration of what I mean, let’ s use a time-honored example taken from Knuth’ s wonderful book Literate Programming. 3 Listing 10-5 shows a translation into Java of Knuth’ s PrintPrimes program.",0.123323224,
q017,refactor large data transformation functions into smaller steps,sparse,2,cc_knowledge_book.pdf:p72_c2,"with care. It should be very clear to the reader that this is an event. Choose names and contexts carefully. Try to avoid any monadic functions that don’t follow these forms, for example, void includeSetupPageInto(StringBuffer pageText). Using an output argument instead of a return value for a transformation is confusing. If a function is going to transform its input argument, the transformation should appear as the return value. Indeed, StringBuffer transform(StringBuffer in) is better than void transform-(StringBuffer out), even if the implementation in the ﬁrst case simply returns the input argument. At least it still follows the form of a transformation. Flag Arguments Flag arguments are ugly. Passing a boolean into a function is a truly terrible practice. It immediately complicates the signature of the method, loudly proclaiming that this function does more than one thing. It does one thing if the ﬂag is true and another if the ﬂag is false! In Listing 3-7 we had no choice because the callers were already passing that ﬂag in, and I wanted to limit the scope of refactoring to the function and below. Still, the method call render(true) is just plain confusing to a poor reader. Mousing over the call and seeing render(boolean isSuite) helps a little, but not that much. We should have split the function into two: renderForSuite() and renderForSingleTest().",0.07176253,
q017,refactor large data transformation functions into smaller steps,sparse,3,cc_knowledge_book.pdf:p207_c1,"176 Chapter 12: Emergence But the most important way to be expressive is to try. All too often we get our code working and then move on to the next problem without giving sufﬁcient thought to making that code easy for the next person to read. Remember, the most likely next person to read the code will be you. So take a little pride in your workmanship. Spend a little time with each of your func- tions and classes. Choose better names, split large functions into smaller functions, and generally just take care of what you’ve created. Care is a precious resource. Minimal Classes and Methods Even concepts as fundamental as elimination of duplication, code expressiveness, and the SRP can be taken too far. In an effort to make our classes and methods small, we might create too many tiny classes and methods. So this rule suggests that we also keep our func- tion and class counts low. High class and method counts are sometimes the result of pointless dogmatism. Con- sider, for example, a coding standard that insists on creating an interface for each and every class. Or consider developers who insist that ﬁelds and behavior must always be sep- arated into data classes and behavior classes. Such dogma should be resisted and a more pragmatic approach adopted. Our goal is to keep our overall system small while we are also keeping our functions and classes small. Remember, however, that this rule is the lowest priority of the four rules of Simple Design. So, although it’ s important to keep class and function count low, it’ s more important to have tests, eliminate duplication, and express yourself. Conclusion Is there a set of simple practices that can replace experience? Clearly not.",0.07050924,
q017,refactor large data transformation functions into smaller steps,sparse,4,cc_knowledge_book.pdf:p67_c1,"36 Chapter 3: Functions So which is it? Is the function doing one thing or three things? Notice that the three steps of the function are one level of abstraction below the stated name of the function. We can describe the function by describing it as a brief TO 4 paragraph: TO RenderPageWithSetupsAndTeardowns, we check to see whether the page is a test page and if so, we include the setups and teardowns. In either case we render the page in HTML. If a function does only those steps that are one level below the stated name of the function, then the function is doing one thing. After all, the reason we write functions is to decompose a larger concept (in other words, the name of the function) into a set of steps at the next level of abstraction. It should be very clear that Listing 3-1 contains steps at many different levels of abstraction. So it is clearly doing more than one thing. Even Listing 3-2 has two levels of abstraction, as proved by our ability to shrink it down. But it would be very hard to mean- ingfully shrink Listing 3-3. We could extract the if statement into a function named includeSetupsAndTeardownsIfTestPage, but that simply restates the code without changing the level of abstraction. So, another way to know that a function is doing more than “one thing” is if you can extract another function from it with a name that is not merely a restatement of its imple- mentation [G34]. Sections within Functions Look at Listing 4-7 on page 71. Notice that the generatePrimes function is divided into sections such as declarations, initializations, and sieve. This is an obvious symptom of doing more than one thing. Functions that do one thing cannot be reasonably divided into sections.",0.0638829,
q017,refactor large data transformation functions into smaller steps,sparse,5,cc_knowledge_book.pdf:p353_c2,"equal to 2. This is a bit of a simpliﬁcation. However, for the purpose of this discussion, we can use this simplifying model. Calculating the Possible Orderings This comes from an email from Uncle Bob to Brett: With N steps and T threads there are T * N total steps. Prior to each step there is a context switch that chooses between the T threads. Each path can thus be represented as a string of digits denoting the context switches. Given steps A and B and threads 1 and 2, the six possible paths are 1122, 1212, 1221, 2112, 2121, and 2211. Or, in terms of steps it is A1B1A2B2, A1A2B1B2, A1A2B2B1, A2A1B1B2, A2A1B2B1, and A2B2A1B1. For three threads the sequence is 112233, 112323, 113223, 113232, 112233, 121233, 121323, 121332, 123132, 123123, . . . . One characteristic of these strings is that there must always be N instances of each T. So the string 111111 is invalid because it has six instances of 1 and zero instances of 2 and 3. NT() ! N!T--------------",0.060616992,
q018,design patterns to improve extensibility in ETL pipelines,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p505_c1,"Chapter 10. Design Patterns with First-Class Functions A NOTE FOR EARLY RELEASE READERS With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles. This will be the 10th chapter of the final book. Please note that the GitHub repo will be made active later on. If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at fluentpython2e@ramalho.org. Conformity to patterns is not a measure of goodness. —Ralph Johnson, Coauthor of the Design Patterns classic In software engineering, a design pattern is a general recipe for solving a common design problem. You don’t need to know design patterns to follow this chapter. I will explain the patterns used in the examples. The use of design patterns in programming was popularized by the landmark book Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley, 1995) by Erich Gamma, Richard Helm, Ralph Johnson & John Vlissides—a.k.a. “the Gang of Four.” The book is a catalog of 23 patterns consisting of arrangements of classes exemplified with code in C++, but assumed to be useful in other Object-Oriented languages as well. 1",0.2002512,
q018,design patterns to improve extensibility in ETL pipelines,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p530_c1,"SOAPBOX Python has first-class functions and first-class types, features that Norvig claims affect 10 of the 23 patterns (slide 10 of Design Patterns in Dynamic Languages). In the Chapter 9, we saw that Python also has generic functions (“Single Dispatch Generic Functions”), a limited form of the CLOS multimethods that Gamma et al. suggest as a simpler way to implement the classic Visitor pattern. Norvig, on the other hand, says that multimethods simplify the Builder pattern (slide 10). Matching design patterns to language features is not an exact science. In classrooms around the world, design patterns are frequently taught using Java examples. I’ve heard more than one student claim that they were led to believe that the original design patterns are useful in any implementation language. It turns out that the “classic” 23 patterns from the Gamma et al. book apply to “classic” Java very well in spite of being originally presented mostly in the context of C++—a few have Smalltalk examples in the book. But that does not mean every one of those patterns applies equally well in any language. The authors are explicit right at the beginning of their book that “some of our patterns are supported directly by the less common object-oriented languages” (recall full quote on first page of this chapter). The Python bibliography about design patterns is very thin, compared to that of Java, C++, or Ruby. In “Further Reading” I mentioned Learning Python Design Patterns by Gennadiy Zlobin, which was published as recently as November 2013. In contrast, Russ Olsen’s Design Patterns in Ruby was published in 2007 and has 384 pages— 284 more than Zlobin’s work. Now that Python is becoming increasingly popular in academia, let’s hope more will be written about design patterns in the context of this language.",0.20024309,
q018,design patterns to improve extensibility in ETL pipelines,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p528_c1,"On the general topic of design patterns, the choice of readings for the Python programmer is not as broad as what is available to other language communities. Learning Python Design Patterns, by Gennadiy Zlobin (Packt), is the only book that I have seen entirely devoted to patterns in Python. But Zlobin’s work is quite short (100 pages) and covers eight of the original 23 design patterns. Expert Python Programming by Tarek Ziadé (Packt) is one of the best intermediate-level Python books in the market, and its final chapter, “Useful Design Patterns,” presents several of the classic patterns from a Pythonic perspective. Alex Martelli has given several talks about Python Design Patterns. There is a video of his EuroPython 2011 presentation and a set of slides on his personal website. I’ve found different slide decks and videos over the years, of varying lengths, so it is worthwhile to do a thorough search for his name with the words “Python Design Patterns.” A publisher told me Martelli is working on a book about this subject. I will certainly get it when it comes out. There are many books about design patterns in the context of Java, but among them the one I like most is Head First Design Patterns, Second Edition by Eric Freeman & Elisabeth Robson (O’Reilly). It explains 16 of the 23 classic patterns. If you like the wacky style of the Head First series and need an introduction to this topic, you will love that work. It is Java- centric, but the Second Edition was uptaded to reflect the addition of first- class functions in Java, making some of the examples closer to code we’d write in Python.",0.18364286,
q018,design patterns to improve extensibility in ETL pipelines,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p529_c1,"In Design Patterns in Dynamic Languages (slides), Peter Norvig shows how first-class functions (and other dynamic features) make several of the original design patterns either simpler or unnecessary. The Introduction of the original Design Patterns book by Gamma et al. is worth the price of the book—more than the catalog of 23 patterns which includes recipes ranging from very important to rarely useful. The widely quoted design principles “Program to an interface, not an implementation” and “Favor object composition over class inheritance” both come from that Introduction. The application of patterns to design originated with the architect Christopher Alexander, presented in the book A Pattern Language ( Oxford University Press, 1977). Alexander’s idea is to create a standard vocabulary allowing teams to share common design decisions while designing buildings. M. J. Dominus wrote “Design Patterns” Aren’t: an intriguing slide deck and postscript text arguing that Alexander’s original vision of patterns is more profound, more human, and also applicable to software engineering.",0.17994371,
q018,design patterns to improve extensibility in ETL pipelines,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p506_c1,"Although design patterns are language-independent, that does not mean every pattern applies to every language. For example, Chapter 17 will show that it doesn’t make sense to emulate the recipe of the Iterator pattern in Python, because the pattern is embedded in the language and ready to use in in the form of generators—which don’t need classes to work, and require less code than the classic recipe. The authors of Design Patterns acknowledge in their Introduction that the implementation language determines which patterns are relevant: The choice of programming language is important because it influences one’s point of view. Our patterns assume Smalltalk/C++-level language features, and that choice determines what can and cannot be implemented easily. If we assumed procedural languages, we might have included design patterns called “Inheritance,” “Encapsulation,” and “Polymorphism.” Similarly, some of our patterns are supported directly by the less common object-oriented languages. CLOS has multi-methods, for example, which lessen the need for a pattern such as Visitor. In his 1996 presentation, “Design Patterns in Dynamic Languages”, Peter Norvig states that 16 out of the 23 patterns in the original Design Patterns book become either “invisible or simpler” in a dynamic language (slide 9). He was talking about the Lisp and Dylan languages, but many of the relevant dynamic features are also present in Python. In particular, in the context of languages with first-class functions, Norvig suggests rethinking the classic patterns known as Strategy, Command, Template Method, and Visitor. The goal of this chapter is to show how—in some cases—functions can do the same work as classes, with code that is shorter and easier to read. We will refactor an implementation of Strategy using functions as objects, removing a lot of boilerplate code. We’ll also discuss a similar approach to simplifying the Command pattern.",0.14152013,
q019,how to reduce dependency on global variables in python scripts,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p597_c1,"Figure 12-1. Reducing functions—reduce, sum, any, all—produce a single aggregate result from a sequence or from any finite iterable object. So far we’ve seen that functools.reduce() can be replaced by sum(), but now let’s properly explain how it works. The key idea is to reduce a series of values to a single value. The first argument to reduce() is a two-argument function, and the second argument is an iterable. Let’s say we have a two-argument function fn and a list lst. When you call reduce(fn, lst), fn will be applied to the first pair of elements—fn(lst[0], lst[1])—producing a first result, r1. Then fn is applied to r1 and the next element—fn(r1, lst[2])— producing a second result, r2. Now fn(r2, lst[3]) is called to produce r3 … and so on until the last element, when a single result, rN, is returned. Here is how you could use reduce to compute 5! (the factorial of 5): >>> 2 * 3 * 4 * 5 # the result we want: 5! == 120 120 >>> import functools >>> functools.reduce(lambda a,b: a*b, range(1, 6)) 120",0.08663637,
q019,how to reduce dependency on global variables in python scripts,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p326_c1,"Let’s start by unlearning that a variable is like a box where you store data. Variables Are Not Boxes In 1997, I took a summer course on Java at MIT. The professor, Lynn Stein made the point that the usual “variables as boxes” metaphor actually hinders the understanding of reference variables in OO languages. Python variables are like reference variables in Java, a better metaphor is to think of variables as labels with names attached to objects. The next example and figure will help you understand why. Example 6-1 is a simple interaction that the “variables as boxes” idea cannot explain. Figure 6-1 illustrates why the box metaphor is wrong for Python, while sticky notes provide a helpful picture of how variables actually work. Example 6-1. Variables a and b hold references to the same list, not copies of the list >>> a = [1, 2, 3] >>> b = a >>> a.append(4) >>> b [1, 2, 3, 4] Create a list [1, 2, 3] and bind the variable a to it Bind the variable b to the same value that a is referencing. Modify the list referenced by a, by appending another item. You can see the effect via the b variable. If we think of b as box that stored a copy of the [1, 2, 3] from the a box, this behavior is makes no sense. 1",0.08549283,
q019,how to reduce dependency on global variables in python scripts,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p367_c1,"Example 7-6. Sum of integers up to 99 performed with reduce and sum >>> from functools import reduce >>> from operator import add >>> reduce(add, range(100)) 4950 >>> sum(range(100)) 4950 >>> Starting with Python 3.0, reduce is no longer a built-in. Import add to avoid creating a function just to add two numbers. Sum integers up to 99. Same task with sum—no need to import and call reduce and add. NOTE The common idea of sum and reduce is to apply some operation to successive items in a sequence, accumulating previous results, thus reducing a sequence of values to a single value. Other reducing built-ins are all and any: all(iterable) Returns True if there are no falsy elements in the iterable; all([]) returns True. any(iterable) Returns True if any element of the iterable is truthy; any([]) returns False. I give a fuller explanation of reduce in “Vector Take #4: Hashing and a Faster ==” where an ongoing example provides a meaningful context for",0.06961067,
q019,how to reduce dependency on global variables in python scripts,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p600_c1,"WARNING When using reduce, it’s good practice to provide the third argument, reduce(function, iterable, initializer), to prevent this exception: TypeError: reduce() of empty sequence with no initial value (excellent message: explains the problem and how to fix it). The initializer is the value returned if the sequence is empty and is used as the first argument in the reducing loop, so it should be the identity value of the operation. As examples, for +, |, ^ the initializer should be 0, but for *, & it should be 1. As implemented, the __hash__ method in Example 12-12 is a perfect example of a map-reduce computation (Figure 12-2).",0.06816895,
q019,how to reduce dependency on global variables in python scripts,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1075_c1,"improvise other forms of flow control with combinations of IF and GOTO—which, again, allowed you to jump to any line of the program. After a few years of programming with jumps and global variables, I remember the struggle to rewire my brain for “structured programming” when I learned Pascal. Now I had to use flow control statements around blocks of code that have a single entry point. I couldn’t jump to any instruction I liked. Global variables were unavoidable in BASIC, but now they were taboo. I needed to rethink the flow of data and explicitly pass arguments to functions. The next challenge for me was learning Object Oriented Programming. At core, OOP is structured programming with more constraints and polymorphism. Information hiding forces yet another rethink of where data lives. I remember being frustrated more than once because I had to refactor my code so that a method I was writing could get information that was encapsulated in an object that my method could not reach. Functional programming languages add other constraints, but immutability is the hardest to swallow after decades of imperative programming and OOP. After we get used to these constraints, we see them as blessings. They make reasoning about the code much easier. Lack of constraints is the main problem with the threads-and-locks model of concurrent programming. When summarizing chapter 1 of Seven Concurrency Models in Seven Weeks, Paul Butcher wrote: The greatest weakness of the approach, however, is that threads-and- locks programming is hard. It may be easy for a language designer to add them to a language, but they provide us, the poor programmers, with very little help. Some examples of unconstrained behavior in that model: Threads can share access to arbitrary mutable data structures.",0.06694234,
q020,"refactoring methods that perform validation, transformation, and storage",sparse,1,cc_knowledge_book.pdf:p72_c2,"with care. It should be very clear to the reader that this is an event. Choose names and contexts carefully. Try to avoid any monadic functions that don’t follow these forms, for example, void includeSetupPageInto(StringBuffer pageText). Using an output argument instead of a return value for a transformation is confusing. If a function is going to transform its input argument, the transformation should appear as the return value. Indeed, StringBuffer transform(StringBuffer in) is better than void transform-(StringBuffer out), even if the implementation in the ﬁrst case simply returns the input argument. At least it still follows the form of a transformation. Flag Arguments Flag arguments are ugly. Passing a boolean into a function is a truly terrible practice. It immediately complicates the signature of the method, loudly proclaiming that this function does more than one thing. It does one thing if the ﬂag is true and another if the ﬂag is false! In Listing 3-7 we had no choice because the callers were already passing that ﬂag in, and I wanted to limit the scope of refactoring to the function and below. Still, the method call render(true) is just plain confusing to a poor reader. Mousing over the call and seeing render(boolean isSuite) helps a little, but not that much. We should have split the function into two: renderForSuite() and renderForSingleTest().",0.08321965,
q020,"refactoring methods that perform validation, transformation, and storage",sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1263_c1,"A class implementing the descriptor protocol. That’s Quantity in Figure 24-1. Managed class The class where the descriptor instances are declared as class attributes —LineItem in Figure 24-1. Descriptor instance Each instance of a descriptor class, declared as a class attribute of the managed class. In Figure 24-1, each descriptor instance is represented by a composition arrow with an underlined name (the underline means class attribute in UML). The black diamonds touch the LineItem class, which contains the descriptor instances. Managed instance One instance of the managed class. In this example, LineItem instances will be the managed instances (they are not shown in the class diagram). Storage attribute An attribute of the managed instance that will hold the value of a managed attribute for that particular instance. In Figure 24-1, the LineItem instance attributes weight and price will be the storage attributes. They are distinct from the descriptor instances, which are always class attributes. Managed attribute A public attribute in the managed class that will be handled by a descriptor instance, with values stored in storage attributes. In other words, a descriptor instance and a storage attribute provide the infrastructure for a managed attribute.",0.07025858,
q020,"refactoring methods that perform validation, transformation, and storage",sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1292_c1,"Chapter Summary The first example of this chapter was a continuation of the LineItem examples from Chapter 23. In Example 24-2, we replaced properties with descriptors. We saw that a descriptor is a class that provides instances that are deployed as attributes in the managed class. Discussing this mechanism required special terminology, introducing terms such as managed instance and storage attribute. In “LineItem Take #4: Automatic Storage Attribute Names”, we removed the requirement that Quantity descriptors were declared with an explicit storage_name, which was redundant and error-prone. The solution was to implement the __set_name__ special method in Quantity, to save the name of the managed property as self.storage_name. “LineItem Take #5: A New Descriptor Type” showed how to subclass an abstract descriptor class to share code while building specialized descriptors with some common functionality. We then looked at the different behavior of descriptors providing or omitting the __set__ method, making the crucial distinction between overriding and non-overriding descriptors, a.k.a. data and non-data descriptors. Through detailed testing we uncovered when descriptors are in control and when they are shadowed, bypassed, or overwritten. Following that, we studied a particular category of non-overriding descriptors: methods. Console experiments revealed how a function attached to a class becomes a method when accessed through an instance, by leveraging the descriptor protocol. To conclude the chapter, “Descriptor Usage Tips” presented practical tips, and “Descriptor docstring and Overriding Deletion” provided a brief look at how descriptor deletion and documentation work.",0.058454946,
q020,"refactoring methods that perform validation, transformation, and storage",sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1260_c1,"Descriptors are a distinguishing feature of Python, deployed not only at the application level but also in the language infrastructure. Besides properties, other Python features that leverage descriptors are methods and the classmethod and staticmethod decorators. Understanding descriptors is key to Python mastery. This is what this chapter is about. What’s new in this chapter The Quantity descriptor example in “LineItem Take #4: Automatic Storage Attribute Names” was dramatically simplified thanks to the __set_name__ special method added to the descriptor protocol in Python 3.6. I removed the property factory example formerly in “LineItem Take #4: Automatic Storage Attribute Names” because it became irrelevant: the point was to show an alternative way of solving the Quantity problem, but with the addition of __set_name__ the descriptor solution becomes much simpler. The AutoStorage class that used to appear in “LineItem Take #5: A New Descriptor Type” is also gone because __set_name__ made it obsolete. Descriptor Example: Attribute Validation As we saw in “Coding a Property Factory”, a property factory is a way to avoid repetitive coding of getters and setters by applying functional programming patterns. A property factory is a higher-order function that creates a parameterized set of accessor functions and builds a custom property instance from them, with closures to hold settings like the storage_name. The object-oriented way of solving the same problem is a descriptor class. We’ll continue the series of LineItem examples where we left it, in “Coding a Property Factory”, by refactoring the quantity property",0.05196892,
q020,"refactoring methods that perform validation, transformation, and storage",sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p179_c1,"code, their position depends on which element is added first. Adding elements to a set may change the order of existing elements. That’s because the algorithm becomes less efficient if the hash table is more than ⅔ full, so Python may need to move and resize the table as it grows. When this happens, elements are reinserted and and their relative ordering may change. See Internals of sets and dicts at fluentpython.com for details. Let’s now review the rich assortment of operations provided by sets. Set Operations Figure 3-2 gives an overview of the methods you can use on mutable and immutable sets. Many of them are special methods that overload operators such as & and >=. Table 3-2 shows the math set operators that have corresponding operators or methods in Python. Note that some operators and methods perform in-place changes on the target set (e.g., &=, difference_update, etc.). Such operations make no sense in the ideal world of mathematical sets, and are not implemented in frozenset. TIP The infix operators in Table 3-2 require that both operands be sets, but all other methods take one or more iterable arguments. For example, to produce the union of four collections, a, b, c, and d, you can call a.union(b, c, d), where a must be a set, but b, c, and d can be iterables of any type that produces hashable items. If you need to create a new set with the union of for iterables, instead of updating an existing set, you can write {*a, *b, *c, *d} since Python 3.5 thanks to PEP 448—Additional Unpacking Generalizations.",0.048597097,
q021,clean architecture guidelines for python backend services,sparse,1,cc_knowledge_book.pdf:p2_c1,Clean Code,0.1661142,
q021,clean architecture guidelines for python backend services,sparse,2,cc_knowledge_book.pdf:p155_c1,"124 Chapter 9: Unit Tests In a way they were right. Their testing effort had failed them. But it was their decision to allow the tests to be messy that was the seed of that failure. Had they kept their tests clean, their testing effort would not have failed. I can say this with some certainty because I have participated in, and coached, many teams who have been successful with clean unit tests. The moral of the story is simple: Test code is just as important as production code. It is not a second-class citizen. It requires thought, design, and care. It must be kept as clean as production code. Tests Enable the -ilities If you don’t keep your tests clean, you will lose them. And without them, you lose the very thing that keeps your production code ﬂexible. Y es, you read that correctly. It is unit tests that keep our code ﬂexible, maintainable, and reusable. The reason is simple. If you have tests, you do not fear making changes to the code! Without tests every change is a possible bug. No matter how ﬂexible your architecture is, no matter how nicely partitioned your design, without tests you will be reluctant to make changes because of the fear that you will introduce undetected bugs. But with tests that fear virtually disappears. The higher your test coverage, the less your fear. Y ou can make changes with near impunity to code that has a less than stellar architecture and a tangled and opaque design. Indeed, you can improve that architecture and design without fear! So having an automated suite of unit tests that cover the production code is the key to keeping your design and architecture as clean as possible. Tests enable all the -ilities, because tests enable change.",0.072125465,
q021,clean architecture guidelines for python backend services,sparse,3,cc_knowledge_book.pdf:p37_c2,"deadlines. In short, they don’t take the time to go fast! True professionals know that the second part of the conundrum is wrong. Y ou will not make the deadline by making the mess. Indeed, the mess will slow you down instantly, and will force you to miss the deadline. The only way to make the deadline—the only way to go fast—is to keep the code as clean as possible at all times. The Art of Clean Code? Let’ s say you believe that messy code is a signiﬁcant impediment. Let’ s say that you accept that the only way to go fast is to keep your code clean. Then you must ask yourself: “How do I write clean code?” It’ s no good trying to write clean code if you don’t know what it means for code to be clean! The bad news is that writing clean code is a lot like painting a picture. Most of us know when a picture is painted well or badly. But being able to recognize good art from bad does not mean that we know how to paint. So too being able to recognize clean code from dirty code does not mean that we know how to write clean code! 2. When hand-washing was ﬁrst recommended to physicians by Ignaz Semmelweis in 1847, it was rejected on the basis that doctors were too busy and wouldn’t have time to wash their hands between patient visits.",0.06829102,
q021,clean architecture guidelines for python backend services,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p415_c1,"LEGACY SUPPORT AND DEPRECATED COLLECTION TYPES (You may skip this box if you only use Python 3.9 or later.) For Python 3.7 and 3.8, you need a __future__ import to make the [] notation work with built-in collections such as list: Example 8-9. tokenize with type hints for Python ≥ 3.7 from __future__ import annotations def tokenize(text: str) -> list[str]: return text.upper().split() That __future__ import does not work with Python 3.6 or earlier. This is how to annotate tokenize in a way that works with Python ≥ 3.5: Example 8-10. tokenize with type hints for Python ≥ 3.5 from typing import List def tokenize(text: str) -> List[str]: return text.upper().split() To provide the initial support for generic type hints, the authors of PEP 484 created dozens of generic types in the typing module. Table 8-1 shows some of them. For the full list, visit the typing documentation.",0.06676956,
q021,clean architecture guidelines for python backend services,sparse,5,cc_knowledge_book.pdf:p189_c1,"158 Chapter 11: Systems empty plots are ﬁlled with larger buildings, some of which will eventually be replaced with skyscrapers. At ﬁrst there are no services like power, water, sewage, and the Internet (gasp!). These services are also added as the population and building densities increase. This growth is not without pain. How many times have you driven, bumper to bumper through a road “improvement” project and asked yourself, “Why didn’t they build it wide enough the ﬁrst time!?” But it couldn’t have happened any other way. Who can justify the expense of a six- lane highway through the middle of a small town that anticipates growth? Who would want such a road through their town? It is a myth that we can get systems “right the ﬁrst time.” Instead, we should imple- ment only today’ s stories, then refactor and expand the system to implement new stories tomorrow. This is the essence of iterative and incremental agility. Test-driven develop- ment, refactoring, and the clean code they produce make this work at the code level. But what about at the system level? Doesn’t the system architecture require preplan- ning? Certainly, it can’t grow incrementally from simple to complex, can it? Software systems are unique compared to physical systems. Their architectures can grow incrementally, if we maintain the proper separation of concerns. The ephemeral nature of software systems makes this possible, as we will see. Let us ﬁrst consider a counterexample of an architecture that doesn’t separate concerns adequately. The original EJB1 and EJB2 architectures did not separate concerns appropriately and thereby imposed unnecessary barriers to organic growth. Consider an Entity Bean for a persistent Bank class. An entity bean is an in-memory representation of relational data, in other words, a table row.",0.06293158,
q022,refactoring monolithic functions into command-query separation,sparse,1,cc_knowledge_book.pdf:p76_c1,"45Command Query Separation Output Arguments Arguments are most naturally interpreted as inputs to a function. If you have been pro- gramming for more than a few years, I’m sure you’ve done a double-take on an argument that was actually an output rather than an input. For example: appendFooter(s); Does this function append s as the footer to something? Or does it append some footer to s? Is s an input or an output? It doesn’t take long to look at the function signature and see: public void appendFooter(StringBuffer report) This clariﬁes the issue, but only at the expense of checking the declaration of the function. Anything that forces you to check the function signature is equivalent to a double-take. It’ s a cognitive break and should be avoided. In the days before object oriented programming it was sometimes necessary to have output arguments. However, much of the need for output arguments disappears in OO lan- guages because this is intended to act as an output argument. In other words, it would be better for appendFooter to be invoked as report.appendFooter(); In general output arguments should be avoided. If your function must change the state of something, have it change the state of its owning object. Command Query Separation Functions should either do something or answer something, but not both. Either your function should change the state of an object, or it should return some information about that object. Doing both often leads to confusion. Consider, for example, the following function: public boolean set(String attribute, String value); This function sets the value of a named attribute and returns true if it is successful and false if no such attribute exists. This leads to odd statements like this: if (set(""username"", ""unclebob""))... Imagine this from the point of view of the reader.",0.106537364,
q022,refactoring monolithic functions into command-query separation,sparse,2,cc_knowledge_book.pdf:p9_c1,viii Contents Avoid Encodings..................................................................................23 Hungarian Notation ..........................................................................23 Member Preﬁxes...............................................................................24 Interfaces and Implementations .......................................................24 Avoid Mental Mapping.......................................................................25 Class Names .........................................................................................25 Method Names.....................................................................................25 Don’t Be Cute ......................................................................................26 Pick One Word per Concept...............................................................26 Don’t Pun .............................................................................................26 Use Solution Domain Names ..............................................................27 Use Problem Domain Names..............................................................27 Add Meaningful Context....................................................................27 Don’t Add Gratuitous Context...........................................................29 Final Words..........................................................................................30 Chapter 3: Functions.........................................................................31 Small!....................................................................................................34 Blocks and Indenting........................................................................35 Do One Thing.......................................................................................35 Sections within Functions ................................................................36 One Level of Abstraction per Function.............................................36 Reading Code from Top to Bottom: The Stepdown Rule..................37 Switch Statements ...............................................................................37 Use Descriptive Names........................................................................39 Function Arguments............................................................................40 Common Monadic Forms.................................................................41 Flag Arguments ................................................................................41 Dyadic Functions..............................................................................42 Triads................................................................................................42 Argument Objects.............................................................................43 Argument Lists.................................................................................43 Verbs and Keywords.........................................................................43 Have No Side Effects...........................................................................44 Output Arguments ............................................................................45 Command Query Separation .............................................................45,0.10181589,
q022,refactoring monolithic functions into command-query separation,sparse,3,cc_knowledge_book.pdf:p77_c1,"46 Chapter 3: Functions could try to resolve this by renaming the set function to setAndCheckIfExists, but that doesn’t much help the readability of the if statement. The real solution is to separate the command from the query so that the ambiguity cannot occur. if (attributeExists(""username"")) { setAttribute(""username"", ""unclebob""); ... } Prefer Exceptions to Returning Error Codes Returning error codes from command functions is a subtle violation of command query separation. It promotes commands being used as expressions in the predicates of if state- ments. if (deletePage(page) == E_OK) This does not suffer from verb/adjective confusion but does lead to deeply nested struc- tures. When you return an error code, you create the problem that the caller must deal with the error immediately. if (deletePage(page) == E_OK) { if (registry.deleteReference(page.name) == E_OK) { if (configKeys.deleteKey(page.name.makeKey()) == E_OK){ logger.log(""page deleted""); } else { logger.log(""configKey not deleted""); } } else { logger.log(""deleteReference from registry failed""); } } else { logger.log(""delete failed""); return E_ERROR; } On the other hand, if you use exceptions instead of returned error codes, then the error processing code can be separated from the happy path code and can be simpliﬁed: try { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } catch (Exception e) { logger.log(e.getMessage()); } Extract Try/Catch Blocks Try/catch blocks are ugly in their own right. They confuse the structure of the code and mix error processing with normal processing. So it is better to extract the bodies of the try and catch blocks out into functions of their own.",0.09198369,
q022,refactoring monolithic functions into command-query separation,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p523_c1,would do. The Command Pattern Command is another design pattern that can be simplified by the use of functions passed as arguments. Figure 10-2 shows the arrangement of classes in the Command pattern.,0.08887937,
q022,refactoring monolithic functions into command-query separation,sparse,5,cc_knowledge_book.pdf:p72_c1,"41Function Arguments Output arguments are harder to understand than input arguments. When we read a function, we are used to the idea of information going in to the function through arguments and out through the return value. We don’t usually expect information to be going out through the arguments. So output arguments often cause us to do a double-take. One input argument is the next best thing to no arguments. SetupTeardown- Includer.render(pageData)is pretty easy to understand. Clearly we are going to render the data in the pageData object. Common Monadic Forms There are two very common reasons to pass a single argument into a function. Y ou may be asking a question about that argument, as in boolean fileExists(“MyFile”). Or you may be operating on that argument, transforming it into something else and returning it . For example, InputStream fileOpen(“MyFile”) transforms a ﬁle name String into an InputStream return value. These two uses are what readers expect when they see a func- tion. Y ou should choose names that make the distinction clear, and always use the two forms in a consistent context. (See Command Query Separation below.) A somewhat less common, but still very useful form for a single argument function, is an event. In this form there is an input argument but no output argument. The overall program is meant to interpret the function call as an event and use the argument to alter the state of the system, for example, void passwordAttemptFailedNtimes(int attempts) . Use this form with care. It should be very clear to the reader that this is an event. Choose names and contexts carefully. Try to avoid any monadic functions that don’t follow these forms, for example, void includeSetupPageInto(StringBuffer pageText). Using an output argument instead of a return value for a transformation is confusing.",0.07894525,
q023,how to restructure code to improve unit test coverage,sparse,1,cc_knowledge_book.pdf:p153_c2,"make sure that those tests were convenient to run for anyone else who needed to work with the code. I would ensure that the tests and the code were checked in together into the same source package. Y es, we’ve come a long way; but we have farther to go. The Agile and TDD move- ments have encouraged many programmers to write automated unit tests, and more are joining their ranks every day. But in the mad rush to add testing to our discipline, many programmers have missed some of the more subtle, and important, points of writing good tests. The Three Laws of TDD By now everyone knows that TDD asks us to write unit tests ﬁrst, before we write produc- tion code. But that rule is just the tip of the iceberg. Consider the following three laws: 1 First Law Y ou may not write production code until you have written a failing unit test. Second Law Y ou may not write more of a unit test than is sufﬁcient to fail, and not com- piling is failing. Third Law Y ou may not write more production code than is sufﬁcient to pass the cur- rently failing test. 1. Professionalism and Test-Driven Development, Robert C. Martin, Object Mentor, IEEE Software, May/June 2007 (V ol. 24, No. 3) pp. 32–36 http://doi.ieeecomputersociety.org/10.1109/MS.2007.85",0.10267624,
q023,how to restructure code to improve unit test coverage,sparse,2,cc_knowledge_book.pdf:p299_c2,"We could quibble about his intention, but I have certainly had to deal with this issue, and I welcome a class that is about dates instead of times. First, Make It Work There are some unit tests in a class named SerialDateTests (Listing B-2, page 366). The tests all pass. Unfortunately a quick inspection of the tests shows that they don’t test every- thing [T1]. For example, doing a “Find Usages” search on the method MonthCodeToQuarter (line 334) indicates that it is not used [F4]. Therefore, the unit tests don’t test it. So I ﬁred up Clover to see what the unit tests covered and what they didn’t. Clover reported that the unit tests executed only 91 of the 185 executable statements in SerialDate (~50 percent) [T2]. The coverage map looks like a patchwork quilt, with big gobs of unex- ecuted code littered all through the class. It was my goal to completely understand and also refactor this class. I couldn’t do that without much greater test coverage. So I wrote my own suite of completely independent unit tests (Listing B-4, page 374). As you look through these tests, you will note that many of them are commented out. These tests didn’t pass. They represent behavior that I think SerialDate should have. So as I refactor SerialDate, I’ll be working to make these tests pass too. Even with some of the tests commented out, Clover reports that the new unit tests are executing 170 (92 percent) out of the 185 executable statements. This is pretty good, and I think we’ll be able to get this number higher. The ﬁrst few commented-out tests (lines 23-63) were a bit of conceit on my part. The program was not designed to pass these tests, but the behavior seemed obvious [G2] to me.",0.091818,
q023,how to restructure code to improve unit test coverage,sparse,3,cc_knowledge_book.pdf:p155_c2,"a tangled and opaque design. Indeed, you can improve that architecture and design without fear! So having an automated suite of unit tests that cover the production code is the key to keeping your design and architecture as clean as possible. Tests enable all the -ilities, because tests enable change. So if your tests are dirty, then your ability to change your code is hampered, and you begin to lose the ability to improve the structure of that code. The dirtier your tests, the dirtier your code becomes. Eventually you lose the tests, and your code rots. Clean Tests What makes a clean test? Three things. Readability, readability, and readability. Read- ability is perhaps even more important in unit tests than it is in production code. What makes tests readable? The same thing that makes all code readable: clarity, simplicity, and density of expression. In a test you want to say a lot with as few expressions as possible. Consider the code from FitNesse in Listing 9-1. These three tests are difﬁcult to understand and can certainly be improved. First, there is a terrible amount of duplicate code [G5] in the repeated calls to addPage and assertSubString. More importantly, this code is just loaded with details that interfere with the expressiveness of the test.",0.08434964,
q023,how to restructure code to improve unit test coverage,sparse,4,cc_knowledge_book.pdf:p345_c1,"314 Chapter 17: Smells and Heuristics T5: Test Boundary Conditions Take special care to test boundary conditions. We often get the middle of an algorithm right but misjudge the boundaries. T6: Exhaustively Test Near Bugs Bugs tend to congregate. When you ﬁnd a bug in a function, it is wise to do an exhaustive test of that function. Y ou’ll probably ﬁnd that the bug was not alone. T7: Patterns of F ailure Are Revealing Sometimes you can diagnose a problem by ﬁnding patterns in the way the test cases fail. This is another argument for making the test cases as complete as possible. Complete test cases, ordered in a reasonable way, expose patterns. As a simple example, suppose you noticed that all tests with an input larger than ﬁve characters failed? Or what if any test that passed a negative number into the second argu- ment of a function failed? Sometimes just seeing the pattern of red and green on the test report is enough to spark the “Aha!” that leads to the solution. Look back at page 267 to see an interesting example of this in the SerialDate example. T8: Test Coverage Patterns Can Be Revealing Looking at the code that is or is not executed by the passing tests gives clues to why the failing tests fail. T9: Tests Should Be F ast A slow test is a test that won’t get run. When things get tight, it’ s the slow tests that will be dropped from the suite. So do what you must to keep your tests fast. Conclusion This list of heuristics and smells could hardly be said to be complete. Indeed, I’m not sure that such a list can ever be complete.",0.084337935,
q023,how to restructure code to improve unit test coverage,sparse,5,cc_knowledge_book.pdf:p155_c1,"124 Chapter 9: Unit Tests In a way they were right. Their testing effort had failed them. But it was their decision to allow the tests to be messy that was the seed of that failure. Had they kept their tests clean, their testing effort would not have failed. I can say this with some certainty because I have participated in, and coached, many teams who have been successful with clean unit tests. The moral of the story is simple: Test code is just as important as production code. It is not a second-class citizen. It requires thought, design, and care. It must be kept as clean as production code. Tests Enable the -ilities If you don’t keep your tests clean, you will lose them. And without them, you lose the very thing that keeps your production code ﬂexible. Y es, you read that correctly. It is unit tests that keep our code ﬂexible, maintainable, and reusable. The reason is simple. If you have tests, you do not fear making changes to the code! Without tests every change is a possible bug. No matter how ﬂexible your architecture is, no matter how nicely partitioned your design, without tests you will be reluctant to make changes because of the fear that you will introduce undetected bugs. But with tests that fear virtually disappears. The higher your test coverage, the less your fear. Y ou can make changes with near impunity to code that has a less than stellar architecture and a tangled and opaque design. Indeed, you can improve that architecture and design without fear! So having an automated suite of unit tests that cover the production code is the key to keeping your design and architecture as clean as possible. Tests enable all the -ilities, because tests enable change.",0.078623384,
q024,strategies for eliminating temporal coupling in workflows,sparse,1,cc_knowledge_book.pdf:p334_c1,"303General public class MoogDiver { Gradient gradient; List<Spline> splines; public void dive(String reason) { saturateGradient(); reticulateSplines(); diveForMoog(reason); } ... } The order of the three functions is important. Y ou must saturate the gradient before you can reticulate the splines, and only then can you dive for the moog. Unfortunately, the code does not enforce this temporal coupling. Another programmer could call reticulate- Splines before saturateGradient was called, leading to an UnsaturatedGradientException. A better solution is: public class MoogDiver { Gradient gradient; List<Spline> splines; public void dive(String reason) { Gradient gradient = saturateGradient(); List<Spline> splines = reticulateSplines(gradient); diveForMoog(splines, reason); } ... } This exposes the temporal coupling by creating a bucket brigade. Each function produces a result that the next function needs, so there is no reasonable way to call them out of order. Y ou might complain that this increases the complexity of the functions, and you’ d be right. But that extra syntactic complexity exposes the true temporal complexity of the situation. Note that I left the instance variables in place. I presume that they are needed by pri- vate methods in the class. Even so, I want the arguments in place to make the temporal coupling explicit. G32: Don’t Be Arbitrary Have a reason for the way you structure your code, and make sure that reason is communi- cated by the structure of the code. If a structure appears arbitrary, others will feel empowered to change it. If a structure appears consistently throughout the system, others will use it and preserve the convention. For example, I was recently merging changes to FitNesse and discovered that one of our committers had done this: public class AliasLinkWidget extends ParentWidget { public static class VariableExpandingWidgetRoot { ... ... }",0.1155259,
q024,strategies for eliminating temporal coupling in workflows,sparse,2,cc_knowledge_book.pdf:p79_c2,"nent Oriented Programming, are all, in part, strategies for eliminating duplication. It would appear that since the invention of the subroutine, innovations in software develop- ment have been an ongoing attempt to eliminate duplication from our source code. Structured Programming Some programmers follow Edsger Dijkstra’ s rules of structured programming. 14 Dijkstra said that every function, and every block within a function, should have one entry and one exit. Following these rules means that there should only be one return statement in a func- tion, no break or continue statements in a loop, and never, ever, any goto statements. 12. This is an example of the Open Closed Principle (OCP) [PPP02]. 13. The DR Y principle. [PRAG]. 14. [SP72].",0.10820548,
q024,strategies for eliminating temporal coupling in workflows,sparse,3,cc_knowledge_book.pdf:p75_c1,"44 Chapter 3: Functions Have No Side Effects Side effects are lies. Y our function promises to do one thing, but it also does other hidden things. Sometimes it will make unexpected changes to the variables of its own class. Sometimes it will make them to the parameters passed into the function or to system glo- bals. In either case they are devious and damaging mistruths that often result in strange temporal couplings and order dependencies. Consider, for example, the seemingly innocuous function in Listing 3-6. This function uses a standard algorithm to match a userName to a password. It returns true if they match and false if anything goes wrong. But it also has a side effect. Can you spot it? The side effect is the call to Session.initialize(), of course. The checkPassword func- tion, by its name, says that it checks the password. The name does not imply that it initial- izes the session. So a caller who believes what the name of the function says runs the risk of erasing the existing session data when he or she decides to check the validity of the user. This side effect creates a temporal coupling. That is, checkPassword can only be called at certain times (in other words, when it is safe to initialize the session). If it is called out of order, session data may be inadvertently lost. Temporal couplings are con- fusing, especially when hidden as a side effect. If you must have a temporal coupling, you should make it clear in the name of the function. In this case we might rename the function checkPasswordAndInitializeSession, though that certainly violates “Do one thing.” Listing 3-6 UserValidator.java public class UserValidator { private Cryptographer cryptographer; public boolean checkPassword(String userName, String password) { User user = UserGateway.findByName(userName);",0.10506126,
q024,strategies for eliminating temporal coupling in workflows,sparse,4,cc_knowledge_book.pdf:p79_c1,"48 Chapter 3: Functions to add new errors because then they have to rebuild and redeploy everything. So they reuse old error codes instead of adding new ones. When you use exceptions rather than error codes, then new exceptions are derivativesof the exception class. They can be added without forcing any recompilation or redeployment.12 Don’t Repeat Y ourself13 Look back at Listing 3-1 carefully and you will notice that there is an algorithm that gets repeated four times, once for each of the SetUp, SuiteSetUp, TearDown, and SuiteTearDown cases. It’ s not easy to spot this duplication because the four instances are intermixed with other code and aren’t uniformly duplicated. Still, the duplication is a problem because it bloats the code and will require four-fold modiﬁcation should the algorithm ever have to change. It is also a four-fold opportunity for an error of omission. This duplication was remedied by the include method in Listing 3-7. Read through that code again and notice how the readability of the whole module is enhanced by the reduction of that duplication. Duplication may be the root of all evil in software. Many principles and practices have been created for the purpose of controlling or eliminating it. Consider, for example, that all of Codd’ s database normal forms serve to eliminate duplication in data. Consider also how object-oriented programming serves to concentrate code into base classes that would otherwise be redundant. Structured programming, Aspect Oriented Programming, Compo- nent Oriented Programming, are all, in part, strategies for eliminating duplication. It would appear that since the invention of the subroutine, innovations in software develop- ment have been an ongoing attempt to eliminate duplication from our source code. Structured Programming Some programmers follow Edsger Dijkstra’ s rules of structured programming.",0.07958636,
q024,strategies for eliminating temporal coupling in workflows,sparse,5,cc_knowledge_book.pdf:p75_c2,"temporal coupling, you should make it clear in the name of the function. In this case we might rename the function checkPasswordAndInitializeSession, though that certainly violates “Do one thing.” Listing 3-6 UserValidator.java public class UserValidator { private Cryptographer cryptographer; public boolean checkPassword(String userName, String password) { User user = UserGateway.findByName(userName); if (user != User.NULL) { String codedPhrase = user.getPhraseEncodedByPassword(); String phrase = cryptographer.decrypt(codedPhrase, password); if (""Valid Password"".equals(phrase)) { Session.initialize(); return true; } } return false; } }",0.073073916,
q025,refactoring python scripts to improve maintainability and modularity,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p133_c2,"learned the trick of assigning slices to variables to improve readability, illustrated in our Example 2-12. The second edition of Python Cookbook was written for Python 2.4, but much of its code works with Python 3, and a lot of the recipes in Chapters 5 and 6 deal with sequences. The book was edited by Alex Martelli, Anna",0.072140075,
q025,refactoring python scripts to improve maintainability and modularity,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1070_c2,"about his and other people’s efforts to improve Python’s support for parallel execution. Snow is the author of PEP 554—Multiple Interpreters in the Stdlib. If approved and implemented, PEP 554 lays the groundwork for future enhancements that may eventually allow Python to use multiple cores without the overheads of multiprocessing. One of the biggest",0.058988847,
q025,refactoring python scripts to improve maintainability and modularity,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1083_c1,"RU CN BR IN FR BD TR EG VN IR PH CD ET ID NG DE JP PK MX US 20 flags downloaded in 1.27s $ python3 flags_asyncio.py RU IN ID DE BR VN PK MX US IR ET EG NG BD FR CN JP PH CD TR 20 flags downloaded in 1.42s The output for each run starts with the country codes of the flags as they are downloaded, and ends with a message stating the elapsed time. It took flags.py an average 7.18s to download 20 images. The average for flags_threadpool.py was 1.40s. For flags_asyncio.py, 1.35 was the average time. Note the order of the country codes: the downloads happened in a different order every time with the concurrent scripts. The difference in performance between the concurrent scripts is not significant, but they are both more than five times faster than the sequential script—and this is just for the small task of downloading 20 files of a few kilobytes each. If you scale the task to hundreds of downloads, the concurrent scripts can outpace the sequential code by a factor or 20 or more. WARNING While testing concurrent HTTP clients against public Web servers you may inadvertently launch a denial-of-service (DoS) attack, or be suspected of doing so. In the case of Example 21-1, it’s OK to do it because those scripts are hardcoded to make only 20 requests. We’ll use Python’s http.server package to run tests later in this chapter. Now let’s study the implementations of two of the scripts tested in Example 21-1: flags.py and flags_threadpool.py. I will leave the third",0.051893815,
q025,refactoring python scripts to improve maintainability and modularity,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1106_c1,"Besides the neat effect, the tqdm function is also interesting conceptually: it consumes any iterable and produces an iterator which, while it’s consumed, displays the progress bar and estimates the remaining time to complete all iterations. To compute that estimate, tqdm needs to get an iterable that has a len, or receive as a second argument the expected number of items. Integrating TQDM with our flags2 examples provides an opportunity to look deeper into how the concurrent scripts actually work, by forcing us to use the futures.as_completed and the asyncio.as_completed functions so that tqdm can display progress as each future is completed. The other feature of the flags2 example is a command-line interface. All three scripts accept the same options, and you can see them by running any of the scripts with the -h option. Example 21-10 shows the help text. Example 21-10. Help screen for the scripts in the flags2 series $ python3 flags2_threadpool.py -h usage: flags2_threadpool.py [-h] [-a] [-e] [-l N] [-m CONCURRENT] [-s LABEL] [-v] [CC [CC ...]] Download flags for country codes. Default: top 20 countries by population. positional arguments: CC country code or 1st letter (eg. B for BA...BZ) optional arguments: -h, --help show this help message and exit -a, --all get all available flags (AD to ZW) -e, --every get flags for every possible code (AA...ZZ) -l N, --limit N limit to N first codes -m CONCURRENT, --max_req CONCURRENT maximum concurrent requests (default=30) -s LABEL, --server LABEL Server to hit; one of DELAY, ERROR, LOCAL, REMOTE (default=LOCAL) -v, --verbose output detailed progress info",0.048186753,
q025,refactoring python scripts to improve maintainability and modularity,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1155_c1,"Example 22-10 wraps up the flags set of examples. We’ll now go from client scripts to writing servers with asyncio. Writing asyncio Servers The classic toy example of a TCP server is an echo server. We’ll build slightly more interesting toys: server-side Unicode character search utilities, first using HTTP with FastAPI, then using plain TCP with asyncio only. These servers let users query for Unicode characters based on words in their standard names from the unicodedata module we discussed in “The Unicode Database”. Figure 22-2 shows a session with the web_mojifinder.py server. Figure 22-2. Browser window displaying search results for “mountain” from the web_mojifinder.py service. The Unicode search logic in these examples is in the InvertedIndex class in the charindex.py module in the Fluent Python 2e code repository. There’s nothing concurrent in that small module, so I’ll only give a brief",0.047151923,
q026,techniques to simplify callback-heavy asynchronous code,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p499_c1,"recommends always using functools.wraps—which we saw in Example 9-16. Graham Dumpleton has a series of in-depth blog posts about techniques for implementing well-behaved decorators, starting with “How You Implemented Your Python Decorator is Wrong”. His deep expertise in this matter is also nicely packaged in the wrapt module he wrote to simplify the implementation of decorators and dynamic function wrappers, which support introspection and behave correctly when further decorated, when applied to methods and when used as attribute descriptors. Chapter 24 in Part VI is about descriptors. Chapter 9, Metaprogramming of the Python Cookbook, Third Edition by David Beazley and Brian K. Jones (O’Reilly), has several recipes from elementary decorators to very sophisticated ones, including one that can be called as a regular decorator or as a decorator factory, e.g., @clock or @clock(). That’s “Recipe 9.6. Defining a Decorator That Takes an Optional Argument” in that cookbook. Michele Simionato authored a package aiming to “simplify the usage of decorators for the average programmer, and to popularize decorators by showing various non-trivial examples,” according to the docs. It’s available on PyPI as the decorator package. Created when decorators were still a new feature in Python, the Python Decorator Library wiki page has dozens of examples. Because that page started years ago, some of the techniques shown have been superseded, but the page is still an excellent source of inspiration. “Closures in Python” is a short blog post by Fredrik Lundh that explains the terminology of closures. PEP 3104 — Access to Names in Outer Scopes describes the introduction of the nonlocal declaration to allow rebinding of names that are neither local nor global.",0.08439382,
q026,techniques to simplify callback-heavy asynchronous code,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1196_c1,"Chapter Summary The problem with normal approaches to asynchronous programming as that they’re all-or-nothing propositions. You rewrite all your code so none of it blocks or you’re just wasting your time. —Alvaro Videla & Jason J. W. Williams, RabbitMQ in Action I chose that epigraph for this chapter for two reasons. At a high level, it reminds us to avoid blocking the event loop by delegating slow tasks to a different processing unit, from a simple thread all the way to a distributed task queue. At a lower level, it is also a warning: once you write your first async def, your program is inevitably going to have more and more async def, await, async with and async for. And using non- asynchronous libraries suddenly becomes a challenge. After the simple spinner examples in Chapter 20, here we really focused on asynchronous programing with native coroutines, starting with the blogdom.py DNS probing example, followed by the concept of awaitables. While reading the source code of flags_asyncio.py, we found the first example of an asynchronous context manager. The more advanced variations of the flag downloading program introduced two powerful functions: the asyncio.as_completed generator and the loop.run_in_executor coroutine. We also saw the concept and application of a semaphore to limit the number of concurrent downloads— as expected from well-behaved HTTP clients. Server-side asynchronous programming was presented through the mojifinder examples: a FastAPI Web service and tcp_mojifinder.py—the latter using just asyncio and the TCP protocol. Asynchronous iteration and asynchronous iterables were the next major topic, with sections on async for, Python’s async console, asynchronous generators, asynchronous generator expressions, and asynchronous comprehensions.",0.0778675,
q026,techniques to simplify callback-heavy asynchronous code,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1182_c1,"The use of async for makes this an asynchronous generator expression. It can be defined anywhere in a Python module. The asynchronous generator expression builds an async_generator object—exactly the same type of object returned by an asynchronous generator function like multi_probe. The asynchronous generator object is driven by the async for statement—which in turn can only appear inside an async def body —or in the magic asynchronous console I used in this example. To summarize: an asynchronous generator expression can be defined anywhere in your program, but it can only be used inside a native coroutine or asynchronous generator function. The remaining constructs introduced by PEP 530 can only be defined and used inside native coroutines or asynchronous generator functions. Asynchronous Comprehensions Yuri Selivanov—the author of PEP 530—justifies the need for asynchronous comprehensions with three short code snippets reproduced next. We can all agree that we should be able to rewrite this code: result = [] async for i in aiter(): if i % 2: result.append(i) Like this: result = [i async for i in aiter() if i % 2] In addition, given a native coroutine fun, we should be able to write this: result = [await fun() for fun in funcs]",0.077454545,
q026,techniques to simplify callback-heavy asynchronous code,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1386_c1,c. Launching Processes with concurrent.futures i. Multi-core Prime Checker Redux d. Experimenting with Executor.map e. Downloads with Progress Display and Error Handling i. Error Handling in the flags2 Examples ii. Using futures.as_completed f. Chapter Summary g. Further Reading 27. 22. Asynchronous Programming a. What’s New in this Chapter b. A few definitions c. Example: Probing Domains i. Guido’s trick to read asynchronous code d. New concept: awaitable e. Downloading with asyncio and aiohttp i. The Secret of Native Coroutines: Humble Generators ii. The all-or-nothing problem f. Asynchronous Context Managers g. Enhancing the asyncio downloader i. Using asyncio.as_completed and a semaphore ii. Using an Executor to Avoid Blocking the Event Loop,0.0692418,
q026,techniques to simplify callback-heavy asynchronous code,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1181_c1,"generators are not awaitable. They are asynchronous iterables, driven by async for or by asynchronous comprehensions. Time to talk about asynchronous comprehensions. Async Comprehensions and Async Generator Expressions PEP 530—Asynchronous Comprehensions introduced the use of async for and await in the syntax of comprehensions and generator expressions, starting with Python 3.6. The only construct defined by PEP 530 that can appear outside an async def body is an asynchronous generator expression. Defining and Using an Asynchronous Generator Expression Given the multi_probe asynchronous generator from Example 22-18, we could write another asynchronous generator returning only the names of the domains found. Here is how—again using the asynchronous console launched with -m asyncio: Example 22-21. domaincheck.py: utility for probing domains using domainlib >>> import asyncio >>> from domainlib import multi_probe >>> names = 'python.org rust-lang.org golang.org n05uch1an9.org'.split() >>> gen_found = (domain async for domain, found in multi_probe(names) if found) >>> gen_found <async_generator object <genexpr> at 0x10a8f9700> >>> async for name in gen_found: ... print(name) ... golang.org python.org rust-lang.org",0.067935206,
q027,how to handle magic numbers and inline configuration values,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p302_c1,"The point is: to provide a handle but no guests, we must pass handle as a keyword argument. The Inheritance section of the dataclasses module documentation explains how the order of the fields is computed when there are several levels of inheritance. NOTE In Chapter 14 we’ll talk about misusing inheritance, particularly when the superclasses are not abstract. Creating a hierarchy of data classes is usually a bad idea, but it served us well here to make Example 5-17 shorter, focusing on the handle field declaration and __post_init__ validation. Example 5-17 is the implementation: Example 5-17. dataclass/hackerclub.py: code for HackerClubMember. from dataclasses import dataclass from club import ClubMember @dataclass class HackerClubMember(ClubMember): all_handles = set() handle: str = '' def __post_init__(self): cls = self.__class__ if self.handle == '': self.handle = self.name.split()[0] if self.handle in cls.all_handles: msg = f'handle {self.handle!r} already exists.' raise ValueError(msg) cls.all_handles.add(self.handle) HackerClubMember extends ClubMember. all_handles is a class attribute.",0.09130902,
q027,how to handle magic numbers and inline configuration values,sparse,2,cc_knowledge_book.pdf:p331_c2,"are simply better written as raw numbers. Y ou might quibble about the WORK_HOURS_PER_DAY case because the laws or conventions might change. On the other hand, that formula reads so nicely with the 8 in it that I would be reluctant to add 17 extra characters to the readers’ burden. And in the FEET_PER_MILE case, the number 5280 is so very well known and so unique a constant that readers would recognize it even if it stood alone on a page with no context surrounding it. Constants like 3.141592653589793 are also very well known and easily recognizable. However, the chance for error is too great to leave them raw. Every time someone sees 3.1415927535890793, they know that it is p, and so they fail to scrutinize it. (Did you catch the single-digit error?) We also don’t want people using 3.14, 3.14159, 3.142, and so forth. Therefore, it is a good thing that Math.PI has already been deﬁned for us. The term “Magic Number” does not apply only to numbers. It applies to any token that has a value that is not self-describing. For example: assertEquals(7777, Employee.find(“John Doe”).employeeNumber()); There are two magic numbers in this assertion. The ﬁrst is obviously 7777, though what it might mean is not obvious. The second magic number is ""John Doe,"" and again the intent is not clear. It turns out that ""John Doe"" is the name of employee #7777 in a well-known test data- base created by our team. Everyone in the team knows that when you connect to this",0.08701464,
q027,how to handle magic numbers and inline configuration values,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p688_c1,"The numbers package defines the so-called numeric tower described in PEP 3141—A Type Hierarchy for Numbers. The tower is linear hierarchy of ABCs, where Number is the topmost ABC, Complex is its immediate subclass, and so on, down to Integral: Number Complex Real Rational Integral So if you need to check for an integer, you can use isinstance(x, numbers.Integral) to accept int, bool (which subclasses int) or other integer types that are provided by external libraries that register their types as virtual subclasses of the numbers ABCs. For example, NumPy has 21 integer types—as well as several variations of floating point types registered as numbers.Real, and complex numbers with various bit widths registered as numbers.Complex. TIP Somewhat surprisingly, decimal.Decimal is not registered as a virtual subclass of numbers.Real. The reason is that, if you need the precision of Decimal in your program, then you want to be protected from accidental mixing of decimals with other less precise numeric types, particularly floating point numbers. Sadly, the numeric tower was not designed for static type checking. The root ABC—numbers.Number—has no methods, so if you declare x: Number then type checkers will not let you do arithmetic or call any methods on x. To be frank, we don’t often need to implement type safe functions that can handle various types of floating point numbers, or integers of varying bit",0.0860108,
q027,how to handle magic numbers and inline configuration values,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p301_c1,"argument:: >>> anna = HackerClubMember('Anna Ravenscroft', handle='AnnaRaven') >>> anna HackerClubMember(name='Anna Ravenscroft', guests=[], handle='AnnaRaven') If ``handle`` is ommitted, it's set to the first part of the member's name:: >>> leo = HackerClubMember('Leo Rochael') >>> leo HackerClubMember(name='Leo Rochael', guests=[], handle='Leo') Members must have a unique handle. The following ``leo2`` will not be created, because its ``handle`` would be 'Leo', which was taken by ``leo``:: >>> leo2 = HackerClubMember('Leo DaVinci') Traceback (most recent call last): ... ValueError: handle 'Leo' already exists. To fix, ``leo2`` must be created with an explicit ``handle``:: >>> leo2 = HackerClubMember('Leo DaVinci', handle='Neo') >>> leo2 HackerClubMember(name='Leo DaVinci', guests=[], handle='Neo') """""" Note that we must provide handle as a keyword argument, because HackerClubMember inherits name and guests from ClubMember, and adds the handle field. The generated docstring for HackerClubMember shows the order of the fields in the constructor call: >>> HackerClubMember.__doc__ ""HackerClubMember(name: str, guests: list = <factory>, handle: str = '')"" Here, <factory> is a short way of saying that some callable will produce the default value for guests (in our case, the factory is the list class).",0.0785127,
q027,how to handle magic numbers and inline configuration values,sparse,5,cc_knowledge_book.pdf:p177_c1,"146 Chapter 10: Classes The ﬁrst thing you might notice is that the program got a lot longer. It went from a little over one page to nearly three pages in length. There are several reasons for this growth. First, the refactored program uses longer, more descriptive variable names. Second, the refactored program uses function and class declarations as a way to add commentary to the code. Third, we used whitespace and formatting techniques to keep the program readable. Notice how the program has been split into three main responsibilities. The main program is contained in the PrimePrinter class all by itself. Its responsibility is to handle the execution environment. It will change if the method of invocation changes. For example, if this program were converted to a SOAP service, this is the class that would be affected. The RowColumnPagePrinter knows all about how to format a list of numbers into pages with a certain number of rows and columns. If the formatting of the output needed changing, then this is the class that would be affected. The PrimeGenerator class knows how to generate a list prime numbers. Notice that it is not meant to be instantiated as an object. The class is just a useful scope in which its variables can be declared and kept hidden. This class will change if the algorithm for computing prime numbers changes. This was not a rewrite! We did not start over from scratch and write the program over again. Indeed, if you look closely at the two different programs, you’ll see that they use the same algorithm and mechanics to get their work done. The change was made by writing a test suite that veriﬁed the precise behavior of the ﬁrst program.",0.06803552,
q028,refactor python functions that mix computation and logging,sparse,1,cc_knowledge_book.pdf:p225_c2,"14-1 Simple use of Args public static void main(String[] args) { try { Args arg = new Args(""l,p#,d*"", args); boolean logging = arg.getBoolean('l'); int port = arg.getInt('p'); String directory = arg.getString('d'); executeApplication(logging, port, directory); } catch (ArgsException e) { System.out.printf(""Argument error: %s\n"", e.errorMessage()); } } Listing 14-2 Args.java package com.objectmentor.utilities.args; import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*; import java.util.*; public class Args { private Map<Character, ArgumentMarshaler> marshalers;",0.05810944,
q028,refactor python functions that mix computation and logging,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p363_c1,"NOTE The First Edition had sections about the introspection of function objects that were too low-level and distracted from the main subject of this chapter. I merged those sections into a post titled Introspection of Function Parameters at fluentpython.com. Now let’s see why Python functions are full-fledged objects. Treating a Function Like an Object The console session in Example 7-1 shows that Python functions are objects. Here we create a function, call it, read its __doc__ attribute, and check that the function object itself is an instance of the function class. Example 7-1. Create and test a function, then read its __doc__ and check its type >>> def factorial(n): ... """"""returns n!"""""" ... return 1 if n < 2 else n * factorial(n - 1) ... >>> factorial(42) 1405006117752879898543142606244511569936384000000000 >>> factorial.__doc__ 'returns n!' >>> type(factorial) <class 'function'> This is a console session, so we’re creating a function at “runtime.” __doc__ is one of several attributes of function objects. factorial is an instance of the function class. The __doc__ attribute is used to generate the help text of an object. In the Python console, the command help(factorial) will display a screen like Figure 7-1.",0.05397287,
q028,refactor python functions that mix computation and logging,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p47_c1,"Chapter Summary By implementing special methods, your objects can behave like the built-in types, enabling the expressive coding style the community considers Pythonic. A basic requirement for a Python object is to provide usable string representations of itself, one used for debugging and logging, another for presentation to end users. That is why the special methods __repr__ and __str__ exist in the data model. Emulating sequences, as shown with the FrenchDeck example, is one of the most common uses of the special methods. For example, database libraries often return query results wrapped in sequence-like collections. Making the most of existing sequence types is the subject of Chapter 2. Implementing your own sequences will be covered in Chapter 12, when we create a multidimensional extension of the Vector class. Thanks to operator overloading, Python offers a rich selection of numeric types, from the built-ins to decimal.Decimal and fractions.Fraction, all supporting infix arithmetic operators. The NumPy data science libraries support infix operators with matrices and tensors. Implementing operators—including reversed operators and augmented assignment—will be shown in Chapter 16 via enhancements of the Vector example. The use and implementation of the majority of the remaining special methods of the Python Data Model are covered throughout this book. Further Reading The “Data Model” chapter of The Python Language Reference is the canonical source for the subject of this chapter and much of this book. Python in a Nutshell, 3rd Edition (O’Reilly) by Alex Martelli, Anna Ravenscroft, and Steve Holden has excellent coverage of the data model. Their description of the mechanics of attribute access is the most",0.053094946,
q028,refactor python functions that mix computation and logging,sparse,4,cc_knowledge_book.pdf:p65_c1,"34 Chapter 3: Functions Unless you are a student of FitNesse, you probably don’t understand all the details. Still, you probably understand that this function performs the inclusion of some setup and teardown pages into a test page and then renders that page into HTML. If you are familiar with JUnit, 2 you probably realize that this function belongs to some kind of Web-based testing framework. And, of course, that is correct. Divining that information from Listing 3-2 is pretty easy, but it’ s pretty well obscured by Listing 3-1. So what is it that makes a function like Listing 3-2 easy to read and understand? How can we make a function communicate its intent? What attributes can we give our functions that will allow a casual reader to intuit the kind of program they live inside? Small! The ﬁrst rule of functions is that they should be small. The second rule of functions is that they should be smaller than that . This is not an assertion that I can justify. I can’t provide any references to research that shows that very small functions are better. What I can tell you is that for nearly four decades I have written functions of all different sizes. I’ve writ- ten several nasty 3,000-line abominations. I’ve written scads of functions in the 100 to 300 line range. And I’ve written functions that were 20 to 30 lines long. What this experience has taught me, through long trial and error, is that functions should be very small. In the eighties we used to say that a function should be no bigger than a screen-full. Of course we said that at a time when VT100 screens were 24 lines by 80 columns, and our editors used 4 lines for administrative purposes.",0.051880628,
q028,refactor python functions that mix computation and logging,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p506_c2,"is to show how—in some cases—functions can do the same work as classes, with code that is shorter and easier to read. We will refactor an implementation of Strategy using functions as objects, removing a lot of boilerplate code. We’ll also discuss a similar approach to simplifying the Command pattern. What’s new in this chapter 2",0.05146743,
q029,best practices to break down god classes into cohesive components,sparse,1,cc_knowledge_book.pdf:p171_c1,"140 Chapter 10: Classes to look to ﬁnd things and need only understand the directly affected complexity at any given time. In contrast, a system with larger, multipurpose classes always hampers us by insisting we wade through lots of things we don’t need to know right now. To restate the former points for emphasis: We want our systems to be composed of many small classes, not a few large ones. Each small class encapsulates a single responsi- bility, has a single reason to change, and collaborates with a few others to achieve the desired system behaviors. Cohesion Classes should have a small number of instance variables. Each of the methods of a class should manipulate one or more of those variables. In general the more variables a method manipulates the more cohesive that method is to its class. A class in which each variable is used by each method is maximally cohesive. In general it is neither advisable nor possible to create such maximally cohesive classes; on the other hand, we would like cohesion to be high. When cohesion is high, it means that the methods and variables of the class are co-dependent and hang together as a logical whole. Consider the implementation of a Stack in Listing 10-4. This is a very cohesive class. Of the three methods only size() fails to use both the variables. The strategy of keeping functions small and keeping parameter lists short can some- times lead to a proliferation of instance variables that are used by a subset of methods. When this happens, it almost always means that there is at least one other class trying to Listing 10-4 Stack.java A cohesive class. public class Stack { private int topOfStack = 0; List<Integer> elements = new LinkedList<Integer>(); public int size() { return topOfStack;",0.09880795,
q029,best practices to break down god classes into cohesive components,sparse,2,cc_knowledge_book.pdf:p172_c1,"141Classes Should Be Small! get out of the larger class. Y ou should try to separate the variables and methods into two or more classes such that the new classes are more cohesive. Maintaining Cohesion Results in Many Small Classes Just the act of breaking large functions into smaller functions causes a proliferation of classes. Consider a large function with many variables declared within it. Let’ s say you want to extract one small part of that function into a separate function. However, the code you want to extract uses four of the variables declared in the function. Must you pass all four of those variables into the new function as arguments? Not at all! If we promoted those four variables to instance variables of the class, then we could extract the code without passing any variables at all. It would be easy to break the function up into small pieces. Unfortunately, this also means that our classes lose cohesion because they accumulate more and more instance variables that exist solely to allow a few functions to share them. But wait! If there are a few functions that want to share certain variables, doesn’t that make them a class in their own right? Of course it does. When classes lose cohesion, split them! So breaking a large function into many smaller functions often gives us the opportu- nity to split several smaller classes out as well. This gives our program a much better orga- nization and a more transparent structure. As a demonstration of what I mean, let’ s use a time-honored example taken from Knuth’ s wonderful book Literate Programming. 3 Listing 10-5 shows a translation into Java of Knuth’ s PrintPrimes program.",0.074601404,
q029,best practices to break down god classes into cohesive components,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p259_c2,"syntax details, codecs, regular expressions, filenames, and best practices for Unicode- aware I/O (i.e., the Unicode sandwich), with plenty of additional reference links from each section. Chapter 4, “Strings”, of Mark Pilgrim’s awesome book Dive into Python 3 also provides a very good intro to Unicode support in Python 3. In the same book, Chapter 15 describes how the Chardet library was ported from Python 2 to Python 3, a valuable case study given that the switch from the old str to the new bytes is the cause of most",0.060160965,
q029,best practices to break down god classes into cohesive components,sparse,4,cc_knowledge_book.pdf:p170_c2,"wholly appropriate. Maintaining a separation of concerns is just as important in our programming activities as it is in our programs. The problem is that too many of us think that we are done once the program works. We fail to switch to the other concern of organization and cleanliness. We move on to the next problem rather than going back and breaking the overstuffed classes into decoupled units with single responsibilities. At the same time, many developers fear that a large number of small, single-purpose classes makes it more difﬁcult to understand the bigger picture. They are concerned that they must navigate from class to class in order to ﬁgure out how a larger piece of work gets accomplished. However, a system with many small classes has no more moving parts than a system with a few large classes. There is just as much to learn in the system with a few large classes. So the question is: Do you want your tools organized into toolboxes with many small drawers each containing well-deﬁned and well-labeled components? Or do you want a few drawers that you just toss everything into? Every sizable system will contain a large amount of logic and complexity. The pri- mary goal in managing such complexity is to organize it so that a developer knows where Listing 10-3 A single-responsibility class public class Version { public int getMajorVersionNumber() public int getMinorVersionNumber() public int getBuildNumber() }",0.056381416,
q029,best practices to break down god classes into cohesive components,sparse,5,cc_knowledge_book.pdf:p21_c2,"or tidiness (think “systematize” in English). There is an old American saying: A place for everything, and everything in its place. A piece of code should be where you expect to ﬁnd it—and, if not, you should re-factor to get it there. • Seiso, or cleaning (think “shine” in English): Keep the workplace free of hanging wires, grease, scraps, and waste. What do the authors here say about littering your code with comments and commented-out code lines that capture history or wishes for the future? Get rid of them. • Seiketsu, or standardization: The group agrees about how to keep the workplace clean. Do you think this book says anything about having a consistent coding style and set of practices within the group? Where do those standards come from? Read on. • Shutsuke, or discipline (self-discipline). This means having the discipline to follow the practices and to frequently reﬂect on one’ s work and be willing to change. If you take up the challenge—yes, the challenge—of reading and applying this book, you’ll come to understand and appreciate the last point. Here, we are ﬁnally driving to the roots of responsible professionalism in a profession that should be concerned with the life cycle of a product. As we maintain automobiles and other machines under TPM, break- down maintenance—waiting for bugs to surface—is the exception. Instead, we go up a level: inspect the machines every day and ﬁx wearing parts before they break, or do the equivalent of the proverbial 10,000-mile oil change to forestall wear and tear. In code, refactor mercilessly. Y ou can improve yet one level further, as the TPM movement inno- vated over 50 years ago: build machines that are more maintainable in the ﬁrst place. Mak- ing your code readable is as important as making it executable.",0.05483201,
q030,refactor long list comprehensions into readable steps,sparse,1,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p58_c1,"Keep in mind these common traits: mutable versus immutable; container versus flat. They are helpful to extrapolate what you know about one sequence type to others. The most fundamental sequence type is the list: a mutable container. I expect you are very familiar with lists, so we’ll jump right into list comprehensions, a powerful way of building lists that is sometimes underused because the syntax may look unusual at first. Mastering list comprehensions opens the door to generator expressions, which—among other uses—can produce elements to fill up sequences of any type. Both are the subject of the next section. List Comprehensions and Generator Expressions A quick way to build a sequence is using a list comprehension (if the target is a list) or a generator expression (for other kinds of sequences). If you are not using these syntactic forms on a daily basis, I bet you are missing opportunities to write code that is more readable and often faster at the same time. If you doubt my claim that these constructs are “more readable,” read on. I’ll try to convince you. TIP For brevity, many Python programmers refer to list comprehensions as listcomps, and generator expressions as genexps. I will use these words as well. List Comprehensions and Readability Here is a test: which do you find easier to read, Example 2-1 or Example 2- 2? Example 2-1. Build a list of Unicode codepoints from a string",0.22720733,
q030,refactor long list comprehensions into readable steps,sparse,2,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p61_c1,"LOCAL SCOPE WITHIN COMPREHENSIONS AND GENERATOR EXPRESSIONS In Python 3, list comprehensions, generator expressions, and their siblings set and dict comprehensions have a local scope to hold the variables assigned in the for clause. However, variables assigned with the “Walrus operator” := remain accessible after those comprehensions or expressions return—unlike local variables in a function. PEP 572—Assignment Expressions defines the scope of the target of := as the enclosing function, unless there is a global or nonlocal declaration for that target. >>> x = 'ABC' >>> codes = [ord(x) for x in x] >>> x 'ABC' >>> codes [65, 66, 67] >>> codes = [last := ord(c) for c in x] >>> last 67 >>> c Traceback (most recent call last): File ""<stdin>"", line 1, in <module> NameError: name 'c' is not defined x was not clobbered: it’s still bound to 'ABC'; last remains; c existed only inside the listcomp. List comprehensions build lists from sequences or any other iterable type by filtering and transforming items. The filter and map built-ins can be composed to do the same, but readability suffers, as we will see next. 2",0.13616106,
q030,refactor long list comprehensions into readable steps,sparse,3,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p1367_c1,d. Overview of Special Methods e. Why len Is Not a Method f. Chapter Summary g. Further Reading 4. II. Data Structures 5. 2. An Array of Sequences a. What’s new in this chapter b. Overview of Built-In Sequences c. List Comprehensions and Generator Expressions i. List Comprehensions and Readability ii. Listcomps Versus map and filter iii. Cartesian Products iv. Generator Expressions d. Tuples Are Not Just Immutable Lists i. Tuples as Records ii. Tuples as Immutable Lists iii. Comparing Tuple and List Methods e. Unpacking sequences and iterables i. Using * to grab excess items ii. Unpacking with * in function calls and sequence literals iii. Nested Unpacking f. Pattern Matching with Sequences,0.116845705,
q030,refactor long list comprehensions into readable steps,sparse,4,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p366_c1,"Functional languages commonly offer the map, filter, and reduce higher-order functions (sometimes with different names). The map and filter functions are still built-ins in Python 3, but since the introduction of list comprehensions and generator expressions, they are not as important. A listcomp or a genexp does the job of map and filter combined, but is more readable. Consider Example 7-5. Example 7-5. Lists of factorials produced with map and filter compared to alternatives coded as list comprehensions >>> list(map(factorial, range(6))) [1, 1, 2, 6, 24, 120] >>> [factorial(n) for n in range(6)] [1, 1, 2, 6, 24, 120] >>> list(map(factorial, filter(lambda n: n % 2, range(6)))) [1, 6, 120] >>> [factorial(n) for n in range(6) if n % 2] [1, 6, 120] >>> Build a list of factorials from 0! to 5!. Same operation, with a list comprehension. List of factorials of odd numbers up to 5!, using both map and filter. List comprehension does the same job, replacing map and filter, and making lambda unnecessary. In Python 3, map and filter return generators—a form of iterator—so their direct substitute is now a generator expression (in Python 2, these functions returned lists, therefore their closest alternative is a listcomp). The reduce function was demoted from a built-in in Python 2 to the functools module in Python 3. Its most common use case, summation, is better served by the sum built-in available since Python 2.3 was released in 2003. This is a big win in terms of readability and performance (see Example 7-6).",0.09093486,
q030,refactor long list comprehensions into readable steps,sparse,5,Fluent.Python.2nd.Edition.(z-lib.org).pdf:p143_c1,"NOTE After adding more than 200 pages in this Second Edition, I moved the optional section Internals of sets and dicts to the fluentpython.com companion Web site. The updated and expanded 18-page post includes explanations and diagrams about: The hash table algorithm and data structures, starting with its use in set, which is simpler to understand. The memory optimization that preserves key insertion order in dict instances (since Python 3.6). The key-sharing layout for dictionaries holding instance attributes—the __dict__ of user-defined objects (optimization implemented in Python 3.3). Modern dict Syntax The next sections decribes advanced syntax features to build, unpack, and process mappings. Some of these features are not new in the language, but but may be new to you. Others require Python 3.9 (like the | operator) or Python 3.10 (like match/case). Let’s start with one of the best and oldest of these features. dict Comprehensions Since Python 2.7, the syntax of listcomps and genexps was adapted to dict comprehensions (and set comprehensions as well, which we’ll soon visit). A dictcomp builds a dict instance by taking key:value pairs from any iterable. Example 3-1 shows the use of dict comprehensions to build two dictionaries from the same list of tuples. Example 3-1. Examples of dict comprehensions >>> dial_codes = [ ... (880, 'Bangladesh'), ... (55, 'Brazil'), ... (86, 'China'), ... (91, 'India'), ... (62, 'Indonesia'), ... (81, 'Japan'), ... (234, 'Nigeria'), ... (92, 'Pakistan'),",0.076838456,
